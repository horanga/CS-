
---

### CPU의 원리


- CPU란? 
	CPU는 컴퓨터의 두뇌이다.
	CPU는 메모리에 저장된 명령어를 읽어 들이고, 
	읽어 들인 명령어를 해석하고, 실행하는 부품이다.


- CPU의 내부 구성 요소
	 1. 산술 논리 장치 (Arithmetic Logic Unit / ALU)
		CPU 내의 계산을 담당하는 장치이다.
		컴퓨터 내부에서 수행되는 대부분의 계산은 ALU가 도맡아 수행한다.
		크게 두가지의 계산을 담당 한다.
		- 덧셈, 뺄셈 같은 산술 계산
		- AND, OR 같은 논리 계산
		  
	2. 제어 장치 (Control Unit / CU)
		제어 장치는 제어 신호라는 전기 신호를 내보내고 명령어를 해석하는 장치이다.
		- CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 메모리 읽기라는 제어 신호를 보낸다. 
		- CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 메모리 쓰기라는 제어 신호를 보낸다.
		
	3. 레지스터 (Register)
		CPU 내부의 작은 임시 저장 장치이다.
		프로그램을 실행하는 데 필요한 값들을 임시로 저장한다.
		CPU 안에는 여러 개의 레지스터가 존재하고 각기 다른 이름과 역할을 가지고 있다.


- 산술 논리 장치 (Arithmetic Logic Unit / ALU)
	계산하는 장치인 ALU는 계산을 하기 위해 피연산자와 수행할 연산이 필요하다
	
	- 플래그 
		연산 결과에 대한 추가적인 상태 정보를 담는다.
		(ex : 연산결과가 음수인지, 0인지, 오버 플로우가 발생했는지 등)
		플러그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보이다.
		이 플래그는 플래그 레지스터에 저장되고, CPU는 이 레지스터를 읽어 연산 결과에 대한
		추가적인 정보를 얻을 수 있다.


- 제어 장치 (Control Unit / CU)
  
	- 제어 장치의 입력 정보
	1. Clock 신호를 받아들인다.
		컴퓨터의 모든 부품을 일사 불란하게 움직일 수 있게 하는 시간 단위
		클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, 
		ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들인다.
	2. 해석해야 할 명령어를 받아들인다.
		CPU가 해석해야 할 명령어는 명령어 레지스터라는 특별한 레지스터에 저장된다.
		제어 장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 
		제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.
	3. 플래그 레지스터 속 플래그 값을 받아들인다.
		제어 장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.
	4. 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.
		제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들인다.
		
	- 제어 장치의 출력 정보
	1.  CPU의 내부와 외부로 제어 신호를 내보낸다.
		- 메모리에 저장된 값을 읽거나 쓰기
		- I/O의 값을 읽거나 새로운 값을 쓰고 싶을 때
		- ALU에 전달하는 제어 신호
		- 레지스터에 전달하는 제어 신호


- 레지스터 (Register)
	1. 프로그램 카운터
		메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어 주소를 저장한다.
	2. 명령어 레지스터 
		헤석할 명령어, 즉 방금 메모리에사 읽어 들인 명령어를 저장하는 레지스터이다.
		제어 장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 보냄
	3. 메모리 주소 레지스터
		메모리의 주소를 저장하는 레지스터이다.
		CPU가 읽어 들이고자하는 주소 값을 버스로 보낼 때 메모리 주소 레지스터를 거친다.
	4. 메모리 버퍼 레지스터
		메모리와 주고받을 값(데이터와 명령어)를 저장하는 레지스터이다. 
		즉, 메모리에 쓰고싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 
		주고받을 값은 메모리 버퍼 레지스터를 거친다.
	5. 범용 레지스터
		일반적으로 자유롭게 사용할 수 있는 레지스터이다. 
		데이터와 주소를 모두 저장할 수 있고 일반적으로 CPU안에는 여러 개의 범용 레지스터들이 있다. 
	6.  플래그 레지스터 
		ALU의 연살결과의 추가적인 상태 정보를 저장하는 레지스터이다. 


---

## 운영체제 면접 질문 리스트

<h3>기본 개념</h3>

- 운영체제란 무엇인가요? 어떤 일을 하나요?
	운영체제는 컴퓨터의 중추적인 소프트웨어로 컴퓨터의 하드웨어나 응용프로그램의
	상호작용을 관리하거나 제어하는 역할을 합니다.
	운영체제의 목적은 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 
	응용 프로그램이 동작하도록 지원하고, 시스템 자원을 효율적으로 관리하여 
	응용 프로그램을 원할하게 동작할 수 있도록 한다.
- CPU의 원리를 간단히 설명해주세요.
	CPU는 컴퓨터의 핵심적인 부품으로, 주로 컴퓨터의 명령어를 해석하고 실행하는 역할을
	합니다. 
	CPU의 핵심적인 장치는 크게 세가지로 
	명령어를 처리하고 실행하는 실질적인 장치인 제어 장치와
	산술과 논리를 담당하는 산술 논리 장치와
	주로 임시 데이터나 중간 결과를 저장하는데 사용되며 작고 빠른 메모리 공간인 레지스터가 
	있습니다.
	CPU의 동작의 기본 원리는 
	명령어 해석 -> 명령어 해독 -> 연산 수행 -> 결과 저장 
	의 단계들이 반복되면서 CPU는 프로그램이나 작업을 처리합니다.
- 운영체제의 커널이란 무엇인가요? 어떤 예시가 있나요?
	커널은 운영 체제의 핵심이 되는 프로그램으로 시스템의 모든 것을 통제 합니다.
	하드웨어와 프로세스의 보안을 책임지며 , 
	한정된 시스템의 자원을 효율적으로 관리하여 프로그램을 실행시키고, 
	운영 체제가 다양한 하드웨어와 효율적으로 소통할수 있도록 하드웨어의 추상화시키는 
	핵심적인 역할 등이 있다. 
	커널의 일종 중 하나인 디바이스 드라이버는 다양한 하드웨어와 운영 체제 간에 상호 이해할 수 있는 명령어로 번역해 주는 역할을 하는데, 이는 일종의 통역과도 같습니다.
- 운영체제의 시스템 호출이란 무엇인가요? 또한 어떤 종류가 있나요?
	사용자 모드의 프로세스 중 하드웨어에 직접 접근해서 필요한 경우
	시스템 콜로 커널 모드를 호출하여 필요한 기능을 사용할 수 있도록 해주는 역할이다.
	시스템 콜의 유형은 아래와 같다.
	1. 프로세스 제어
	2. 파일 조작
	3. 장치 관리
	4. 정보 유지
	5. 통신
- 운영체제 내에서 시스템 호출이 일어나면 어떤 일이 일어나는지 순서대로 설명해주세요.
	1. 사용자 프로세스에서 호출
	2. 라이브러리 함수 호출
	3. 유저 모드에서 커널 모드로 전환
	4. 인터럽트 발생 및 시스템 콜 핸들러 실행
	5. 필요한 동작 수행
	6. 결과 반환 및 커널 모드에 유저 모드로 전환
	7. 사용자 프로세스로 복귀
- 스왑(Swap)이란 무엇인가요? 그리고 어떤 상황에서 사용되나요?
	Swap이란 cpu의 ram의 용량이 100%가 넘고도 실행 중인 프로세스를 유지하기 위해 
	임시적으로 보조기억장치에 자원을 할당시키기 위한 임시 저장 영역이다. 
	주로 메모리 부족이나 프로세스를 유지하기 위해 사용된다.
- 컨텍스트 스위칭이란 무엇인가요? 그리고 이 과정에서 어떤 일이 일어나나요?
	컨텍스트 스위칭은 컴퓨터의 작업을 동시에 처리할 수 있도록 해주는 기법으로, 작업을 빠르게 전환하여 여러 프로세스가 동시에 실행되는 것처럼 보이게 합니다. 그러나 컨텍스트 스위칭은 현재 프로세스의 상태 정보를 저장하고 새로운 프로세스의 상태 정보를 복원하는 오버헤드를 발생시킵니다. 
	이 오버헤드가 커질수록 시스템의 성능이 저하되고 자원이 낭비될 수 있습니다.
	효과적인 컨텍스트 스위칭을 위해선 프로세스 스케줄링이 필요하며, 멀티코어 환경에서
	병렬 작업을 고려하여 컨텍스트 스위칭을 더욱 효과적으로 수행할 수 있습니다.
- PCB에는 어떤 정보들이 있고, 어떻게 사용되나요? 
	  PCB는 각 프로세스에 대한 정보를 담겨 있으며
	  프로세스 관리, 컨텍스트 스위칭, 스케줄링 등의 용도로 사용되고 있습니다.
	  PCB의 담겨있는 정보는 아래와 같습니다.
	1. Process ID
	2. Process State
	3. Program Counter
	4. Register
	5. CPU Scheduling Information
	6. Memory Information
	7. Process Information
	8. Device I/O Status
- 커널 모드와 사용자 모드의 차이는 무엇이며, 왜 필요한가요?
	커널 모드와 사용자 모드는 운영체제의 보안 및 안정성을 유지하기 위한 중요한 메커니즘입니다.
	사용자 모드에서는 제한된 권한을 갖고 있어, 주로 응용 프로그램이 실행될 때 사용됩니다. 이 모드에서는 일반적으로 사용자가 직접 조작하는 프로그램이 실행되며, 운영체제의 핵심 부분에 접근할 수 없습니다. 이로써 일반 사용자의 실수나 악의적인 의도로 인한 시스템 손상을 방지할 수 있습니다.

	반면에 커널 모드에서는 운영체제의 핵심 부분이 실행되며, 모든 메모리와 레지스터에 접근할 수 있습니다. 이 권한을 가진 프로세스는 시스템 리소스 및 하드웨어를 효과적으로 관리할 수 있습니다. 하지만 이 권한을 가진 프로세스가 악의적으로 시스템을 손상시킬 수 있으므로, 커널 모드는 보안적으로 신중하게 관리되어야 합니다.

	따라서 사용자 모드와 커널 모드의 구분은 운영체제의 안전성과 보안을 유지하기 위한 중요한 디자인 원칙 중 하나입니다.
- 인터럽트 핸들러에 대해 설명하고, 어떻게 구현되는지 설명해주세요.
	인터럽트 핸들러는 컴퓨터 시스템에서 발생하는 인터럽트에 대응하여 실행되는
	특수한 함수입니다. 인터럽트는 예끼치 않은 이벤트 또는 하드웨어와 소프트웨어 간의
	통신을 위한 메커니즘으로 예를 들어 하드웨어 장치에서의 외부 이벤트, 예외 상황, 
	또는 소프트웨어에서의 요청 등이 해당될 수 있습니다.
	다음은 인터럽트 처리의 단계입니다
	1. 인터럽트 발생 
	2. 현재 작업 중단
	3. 인터럽트 핸들러 실행
	4. 인터럽트 처리 완료 및 복귀
<br>

<h3>프로세스 및 스레드</h3>

- 프로세스와 스레드의 차이점은 무엇인가요?
	프로세스는 작업의 단위로 
	프로세스는 독립적인 메모리 공간을 갖고 운영체제로부터 독립된 메모리 공간을
	할당받아 실행됩니다. 따라서 한 프로세스가 다른 프로세스의 데이터나 자원에 
	직접적으로 접근할 수 없도록 만들어졌기에
	프로세스 간의 통신이 필요할 경우 IPC(프로세스 간 통신)을 사용 해야합니다.
	
	스레드는 프로세스의 실질적인 실행의 단위로
	한 프로세스 내의 자원을 다른 스레드와 메모리를 공유하므로, 스레드 간 통신이
	비교적 간단합니다.
	
	따라서 프로세스는 독립적인 실행 환경을 제공하고, 스레드는 프로세스 내에서
	공유된 환경에서 실행되는 작은 실행 단위입니다. 
	스레드를 사용하면 프로셋스 간 통신보다 경제적으로 자원을 활용할 수 있지만, 
	스레드 간 동기화와 관련된 복잡성에 대비해야 합니다.
- 멀티스레딩과 멀티프로세싱의 차이점은 무엇인가요? 각각의 장점과 한계점을 예시로 설명해주세요.
	멀티 스레딩
	- 장점
	1. 자원 공유 및 효율성
	2. 응답성 향상
	- 한계 
	1. 동기화문제와 경쟁 상태
	2. 노는 스레드로 인한 리소스 낭비
	
	멀티 프로세스
	- 장점
	1. 프로그램 안전성
	2. 시스템 확장성
	- 단점
	4. Context Swiching Overhead
	5. 자원 공유 비효율성
- IPC란 무엇인가요? 또한, IPC가 필요한 이유는 무엇인가요?
	IPC는 Inter-Process Communication의 약자로 프로세스 간 통신이라는 뜻이다.
	멀티 프로세스는 서로 독립적인 메모리 공간과 데이터, 자원을 가지고 있기에 
	일반적인 서로의 통신이 불가능하다 이를 해결하기 위한 메커니즘이 IPC이다
- 프로세스 간 통신(IPC) 방법으로 파이프와 메시지 큐의 차이는 무엇인가요?
	
	차이점을 요약하자면 
	1. 통신 방향은 파이프는 단방향 메시지 큐는 양방향이다.
	2. 프로세스 간 통신은 파이프는 주로 부모-자식 프로세스 간에 사용되며 
	   메시지 큐는 독립적인 프로세스 간에도 사용 가능하다.
	3. 파이프는 운영체제 수준에서 단순한 통신을 제공하고, 메시지 큐는 신뢰성 있는 
	   통신과 다양한 메시지 패턴을 지원한다.
	
	- 파이프 (Pipe)
		1. 단방향 통신
		2. 부모-자식 프로세스 간 통신
		3. 운영체제 기능
		4. 간단하고 경량
	- 메시지 큐 (Message Queue)
		1.  양방향 통신
		2. 독립적인 프로세스 간 통신
		3. 운영체제나 미들웨어의 지원
		4. 신뢰성 및 유연성
- 교착상태(데드락)란 무엇인가요? 어떤 조건이 필요한가요? 또한 해결 전략에는 어떤 것들이 있나요?
	데드락이란 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로
	'교착 상태'라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 
	할 때 발생합니다.
	
	P1과 P2가 리소스 A와 B를 얻어야 하는 상황에서, 초기 상태에서 P1이 리소스 A를 요청하고 P2가 리소스 B를 요청한다고 가정해 봅시다. 이때, P1이 먼저 리소스 A를 얻고, 동시에 P2가 리소스 B를 얻는다면, 다음 단계에서 P1은 리소스 B를 기다리고, P2는 리소스 A를 기다리게 됩니다. 이러한 상태에서 두 프로세스는 서로가 원하는 리소스를 가지고 있어 상호 대기하게 되며, 이를 데드락 상태라고 합니다.
	
	이러한 데드락을 해결법으로는 여러가지가 있는데 
	- 교착 상태 예방 (Deadlock Provention)
		- 상호 배제 부정 : 읽기 전용파일과 같은 공유 자원을 사용합니다
		- 점유 및 대기 부정 : 
			- 프로세스 대기를 없애기 위해서 프로세스 실행전 필요한 모든 자원 할당
			- 자원을 점유하지 않을 때에만 다른 자원을 요청
		- 비선점 부정 : 
			- 모든 자원에 대한 선점을 허용
			- 프로세스가 할당받을 수 없는 자원을 요청하는 경우
			- 기존에 가지고 있던 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기하도록 한다.
		- 순환 대기 부정 : 자워에 고유한 번호를 할당, 번호 순서대로 자원을 요구
		  
	- 교착 상태 회피 (Deadlock Avoidance)
		교착 상태가 발생하기전 예상을 하여 안전한 상태에서만 자원 요청을 허용하는 방법입니다. 자원을 신중하게 할당하면 교착 상테를 회피할 수 있습니다.
		- 교착 상태 회피의 필요한 조건
			- 프로세스 수가 고정되어 있어야 한다.
			- 자원의 종류와 수가 고정되어 있어야 한다.
			- 프로세스가 요구하는 자원 및 최대 자원의 수를 알아야 한다.
			- 프로세스는 반드시 자원을 사용 후 반납해야 한다.
		- 다만 이러한 가정들이 필요하기에 현실성이 부족하다
		- 교착 상태 회피를 위한 알고리즘
			- 자원 할당 그래프 알고리즘
			- 은행원 알고리즘
			- 대기 그래프
- 프로세스의 상태 전이에 대해 설명해주세요.
	프로세스가 대기, 실행, 차단, 종료 등의 상태 사이를 전환하는 것을 말합니다.
	프로세스가 시스템에서 실행될 때 그 상태가 변화하는 과정을 나타냅니다.
	각 상태는 프로세스의 생명 주기에서 특정 단계를 나타내며, 프로세스는 이러한 상태 간
	전이를 거치면서 실행됩니다.
- 운영체제에서의 사용자 레벨 스레드와 커널 레벨 스레드의 차이점은 무엇인가요?
	- 사용자 레벨 스레드
		- 사용자 프로그램이 스레드를 직접 관리
		- 스레드의 생성, 스케줄링, 동기화 등이 사용자 프로그램 내에서 처리
		- 각 스레드는 사용자 프로그램 내에서 독립적으로 실행
		- 여러 스레드가 동시에 실행될 수 있지만, 블록 되면 다른 스레드가 대기 상태에 있을 수 있음.
	- 커널 레벨 스레드
		- 운영체제가 스레드를 직접 관리
		- 스레드의 생성, 스케줄링, 동기화 등이 운영채제 내에서 처리
		- 각 스레드는 독립적으로 운영체에 의해 실행
		- 전체 프로세스의 동작에 대한 제어를 운영체제가 담당
- 운영체제에서의 교착상태와 기아상태의 차이점은 무엇인가요?
	- 교착 상태 (Deadlock)
		 - 교착 상태는 둘 이상의 프로세스가 서로의 보유 자원을 대기하고 있어서, 더 이상 진행하지 못하는 상태를 말합니다.
	    - 일반적으로 "상호배제" (Mutual Exclusion), "점유와 대기" (Hold and Wait), "비선점" (No Preemption), "순환 대기" (Circular Wait)의 네 가지 조건이 충족될 때 교착 상태가 발생합니다.
	- 기아 상태 (Starvation)
		- 기아 상태는 특정 프로세스가 원하는 자원을 계속해서 할당받지 못해 영원히 진행하지 못하는 상태를 나타냅니다.
		- 교착 상태와 달리, 기아 상태에서는 특정 프로세스만이 영원히 자원을 할당받지 못하고 있습니다.
	- 따라서, "교착 상태"는 다수의 프로세스 간에 자원 할당에 대한 상호 대기가 발생할 때, 그리고 "기아 상태"는 특정 프로세스가 자원을 할당받지 못해 영원히 대기할 때 발생합니다.
<br>

<h3>메모리 및 파일 시스템</h3>

- 메모리 영역의 구조에 대해 설명해주세요.
	- 코드 영역 
		- 프로그램의 실행 코드가 저장되는 영역
		- CPU는 코드 영역에 저장된 명령어를 읽어 실행
		- 코드 영역은 읽기 전용으로 설정, 프로그램이 실행 중 수정이 불가
	- 데이터 영역
		- 전역 변수 및 정적 변수가 저장되는 영역
		- 초기화된 전역 변수와 정적 변수는 프로그램이 시작될 때 초기화값으로 초기화
	- 힙 영역
		- 동적으로 할당된 메모리가 저장되는 영역
		- 프로그램이 실행 중에 동적으로 메모리를 할당하고 해제할 수 있음
		- 메모리 관리자에 의해 관리되며, 사용자가 직접 제어할 수 있는 영역
	- 스텍 영역
		- 지역 변수 및 함수 호출에 관련된 정보가 저장되는 영역
		- 함수가 호출될 때마다 스텍에 새로운 프레임이 생성, 함수의 지역 변수 및 복귀 주소 등이 저장
		- 함수가 반환되면 해당 프레임이 스택에서 제거
- 힙과 스택영역에 저장되는 변수에 대한 설명을 코드를 예시로 들어 설명해주세요.
	- 힙 영역
		동적으로 할당 된 메모리를 저장하는 공간으로 주로 동적으로 생성된 변수나
		베열이나 리스트같은 데이터 구조를 저장합니다.
	- 스택 영역
		함수 호출 시 지역 변수, 매개 변수, 함수 호출 정보 등 휘발성 데이터들을 저장합니다.	
- 운영체제에서의 메모리 관리 전략에는 어떤 것들이 있나요?
	1. 단일 연속 메모리 할당 
		   메모리를 단일 연속된 블록으로 관리하는 방식
		   프로세스는 메모리의 일부에 할당되며 크기에 따라 분할 가능하다.
		   이 방식은 간단하지만, 외부 단편화로 인해 효율성이 저하될 수 있다.
	2. 분할 할당 
		메모리를 여러개의 작은 블록으로 나누어 사용하는 방식
		각각의 블록은 하나의 프러세스에 할당
		내부 단편화로 인해 일부 메모리가 낭비될 수 있다.
	3. 페이징
		메모리를 고정된 크기의 페이지로 나누고, 
		프로세스를 동일한 크기의 페이지로 분할하여 메모리에 저장하는 방식
		외부 단편화 문제를 해결하고 효율적인 메모리 관리를 제공
	4. 세그멘테이션 
		프로세스를 여러 논리적 세그먼트로 나누고, 
		각 세그먼트를 다른 크기로 할당하는 방식이다.
		세그먼트는 논리적으로 관련된 데이터 또는 코드 블록을 나타낸다.
		이는 메모리 사용의 유연성을 높일 수 있다.
	5. 가상 메모리
		물리적 메모리와 디스크의 조합을 사용하여 프로세스에 
		더 큰 메모리 공간을 제공하는 방식
		필요한 부분만 실제로 물리적 메모리에 로드되고, 나머지는 디스크에 저장된다.
- 가상 메모리란 무엇인가요? 또한, 페이지 교체 알고리즘에 대해 설명해주세요.
	가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 
	어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 
	실행이 가능하다는 점에 착안하여 고안되었습니다.
	
	페이지 교체 알고리즘은 가상 메모리에서 페이지 부재(page fault)가 발생했을 때 
	어떤 페이지를 물리적 메모리에서 내리고 새로운 페이지를 올릴지를 결정하는 
	알고리즘입니다. 
	페이지 부재는 프로세스가 필요로 하는 페이지가 	현재 물리적 메모리에 없는 
	상황을 의미합니다. 
	다양한 페이지 교체 알고리즘이 존재하며, 각 알고리즘은 프로세스의 
	페이지 부재를 최소화하거나 효율적으로 관리하기 위한 목적을 가지고 있습니다.
	1. FIFO : 먼저 메모리에 들어온 페이지를 먼저 내보낸다.
	2. LRU : 가장 오랫동안 사용되지 않은 페이지를 내보낸다.
	3. LFU : 가장 적게 사용된 페이지를 내보낸다.
	4. Clock : 페이지들을 돌면서 참조 비트를 확인, 참조되지 않은 페이지를 찾아내어 보낸다.
- 페이지와 세그먼트의 차이점은 무엇인가요?
	1. 크기 
		- 페이지 : 고정된 크기의 블록으로 나누어진 메모리 조각
		- 세그먼트 : 서로 다른 크기를 가질 수 있는 메모리 블록
	2. 내부 단편화
		- 페이지 : 고정된 크기 때문에 내부 단편화 발생 가능.
		- 세그먼트 : 다양한 크기로 내부 단편화 가능성 낮음.
	3. 주소 지정
		- 페이지 : 페이지 번호와 오프셋으로 논리적 주소 구성
		- 세그먼트 세그먼트 식별자와 오프셋으로 논리적 주소 구성
	4. 외부 단편화
		- 페이지 : 고정 크기로 나누어져 외부 단편화 발생 가능.
		- 세그먼트 : 다양한 크기로 외부 단편화 가능성 낮음.
	5. 동적 할당
		- 페이지 : 고정 크기로 동적 할당 어려움.
		- 세그먼트 : 다양한 크기로 동적 할당 및 헤제 유연.
	6. 구현의 복잡성
		- 페이지 : 구현이 상대적으로 간단.
		- 세그먼트: 구현이 상대적으로 복잡할 수 있음. 
- 페이지 폴트(Page Fault)가 발생하는 상황과 처리 과정을 설명해주세요.
	페이지 폴트는 프로그램이 실행되는 동안 필요한 페이지가 
	현재 물리적 메모리에 없을 때 발생하는 상황을 나타냅니다. 
	프로세스가 접근하려는 페이지가 현재 메모리에 로드되어 있지 않으면 페이지 폴트가 발생하고 운영체제는 이 상황을 처리해야 합니다.
	
	- 페이지 폴트 발생 상황 : 
		1. 페이지가 처음 필요한 경우
			프로그램이 시작될 때 또는 특정 부분이 처음으로 실행될 때 해당 페이지가
			메모리에 로드되어 있지 않을 수 있다.
		2. 사용자가 새로운 영역으로 이동한 경우
			프로그램이 특정 부분을 실행하다가 새로운 페이지로 이동할 때 
			이전 페이지는 메모리에서 내려가고 새로운 페이지가 필요할 때 페이지 폴트가 발생할 수 있다.
	- 페이지 폴트 처리 과정 : 
		1. 페이지 테이블 검색
			프로세스가 특정 논리적 주소에 접근하려 할 때 운영체제는 페이지 테이블을 
			검색하여 해당 페이지가 현재 메모리에 있는지 확인합니다.
		2. 페이지가 메모리에 없는 경우 
			페이지 테이블 검색에서 해당 페이지가 메모리에 없다는 것을 확인하면 
			페이지 폴트가 발생한 것입니다. 이때 다음과 같은 과정이 발생합니다.
			
			a. 디스크에서 페이지 로드
				필요한 페이지는 디스크에서 메모리로 로드됩니다.
			
			b. 페이지 테이블 업데이트
				 페이지 테이블을 업데이트하여 해당 페이지가 현재 메모리에 
				 로드되었다는 정보를 기록합니다.
	
			c. 인터럽트와 재시작
				페이지 폴트가 발생한 지점에서 프로세스의 실행을 멈추고 페이지 폴트 핸들러(인터럽트 서비스 루틴)가 실행됩니다. 페이지 폴트 핸들러는 필요한 페이지를 메모리로 로드하고, 프로세스를 중단된 지점에서 다시 시작합니다.
- 파일 시스템이란 무엇인가요? 파일 할당 방식에는 어떤 것들이 있나요?
	파일 시스템은 컴퓨터 시스템에서 데이터를 저장하고 조직하는 데 사용되는 체계 
	또는 소프트웨어입니다. 
	파일 시스템은 디스크, SSD 등의 저장 장치에 데이터를 저장하고, 
	이를 효율적으로 관리하여 사용자 및 응용 프로그램이 쉽게 파일을 
	생성, 읽기, 쓰기, 삭제할 수 있도록 합니다.
	
	1. 파일 및 디렉터리 관리
		파일과 디렉터리를 생성, 삭제, 이동, 복사할 수 있는 인터페이스를 제공한다.
	2. 접근 제어
		파일 및 디렉터리에 대한 접근 권한을 관리하여 보안을 유지한다.
	3. 파일 할당 및 저장
		물리적인 저장 장치에 파일을 할당하고, 파일의 논리적인 구조를 물리적인
		저장 장치에 매핑한다.
	4. 파일 검색 및 탐색
		파일을 찾고, 디렉터리를 탐색하는 기능을 제공한다.
	5. 파일 속성 및 메타데이터 관리 
		파일 속성 (크기, 생성일 등) 및 메타데이터를 저장하고 관리한다.
		
	- 파일 할당 방식 
		1. 연속 할당
			파일을 연속된 블록으로 저장하는 방식
		2. 링크드 할당
			각 블록이 다음 블록을 가리키는 링크(포인터)를 가지고 있는 방식
		3. 색인 할당 
			각 파일에 대한 인덱스 블록을 사용하여 각 블록의 위치를 기록하는 방식
		4. 다중 할당 
			여러 수준의 인덱스 블록을 사용하여 대용량 파일의 위치를 기록하는 방식
		5. 혼합 할당
			연속 할당과 링크드 할당, 또는 색인 할당과 연속 할당 등의 방식을 혼합하여 사용하는 방식, 이를 통해 각 방식의 단점을 보완하고 효율성을 높임
- 파일 시스템에서 접근 제어(Access Control)의 역할에 대해 설명해주세요.
	파일 시스템의 접근 제어는 파일과 디렉터리에 대한 권한을 설정하여 
	사용자가 데이터에 접근, 수정, 실행하는 것을 통제합니다. 
	이로써 시스템 보안을 유지하고 무단 액세스로부터 데이터를 보호합니다.
<br>

<h3>동기화 및 스케줄링</h3>

- 프로세스(스레드) 동기화에 대해 설명해주세요.
	여러개의 실행 흐름이 서로 협력하거나 데이터를 안전하게 공유하기 위해
	조절되는 메커니즘이다. 이는 경쟁 조건이나 일관성 문제를 방지하며, 
	프로그램의 정확성과 안정성을 유지하는 데 중요하다.
	
	- 주요 개념과 기법 
	1. 상호 배제
	2. 임계 영역
	3. lock
	4. Semaphore
	5. 조건 변수
	6. 파이프 라인
- 임계영역이란 무엇인가요?
	오직 하나의 프로세스 또는 스레드만이 접근할 수 있도록 보장하는 기법이다.
	임계 영역을 정확히 동작하려면 다음과 같은 조건을 충족해야 한다.
	- 상호 배제 : 임계 영역을 들어가는 각각 프로세스 또는 스레드가 동시에 접근 할 수 없어야 한다.
	- 진행 : 임계 영역에 아무도 없는 상태에서 접근하려는 프로세스 또는 스레드가 있으면, 그 중 하나는 빨리 들어갈 수 있어야 한다.
	- 한정된 대기 : 프로세스 또는 스레드가 임계 영역에 들어가기 위해 대기하는 시간은 유한해야 한다.
- 세마포어와 뮤텍스의 차이점은 무엇인가요?
	- 세마포어
		- 리소스의 개수를 나타내며 여러 프로세스가 공유 리소스에 접근할 때 사용된다.
		- 값에 따라 리소스의 개수를 조절하고 다른 프로세스가 값을 변경할 수 있다.
	- 뮤텍스
		- 상호 배제를 위한 동기화 도구로, 한 번에 하나의 프로세스 또는 스레드만이 임계 영역에 접근할 수 있다. 
		- 소유한 스레드만이 락을 해제할 수 있고, 초기화가 필요하지 않다.	
- 뮤텍스와 세마포어를 선택할 때 어떤 상황에서 어떤 것을 사용해야 하는지 설명해주세요.
	- 세마포어
		- 용도 : 리소스의 개수를 조절하며 여러 프로세스 또는 스레드 간의 접근을 조절 할 때
		- 적절한 상황 : 리소스의 개수나 특정 조건을 관리하고자 할 때
	- 뮤텍스
		- 상호 배제를 위한 동기화 도구
		- 공유 자원에 대한 접근을 단일 스레드에게 제한하고자 할 때
- CPU 스케줄링 알고리즘에 대해 설명해주세요.
	언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업
	이 알고리즘은 CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, 준비 큐에 있는
	프로세스는 적게, 응답시간은 짧게 설정하는 것을 목표로 한다.
	- FCFS
	- SJF
	- Round Robin
	- Priority Scheduling
	- Multilevel Queue
	- Multilevel Feedback Queue
- 프로세스 스케줄링에서 우선순위 스케줄링에 대해 설명해주세요.
	특정 기준으로 프로세스에게 우선순위를 부여해 우선순위가 제일 높은 프로세스에게
	CPU를 할당하는 방식이다.
	일반적으로 숫자가 작으면 우선순위가 높은 것을 의미하며, 
	SJF도 일종의 우선순위 스케줄링이다.
	
	다만 이방식 또한 우선순위가 낮은 프로세스가 계속해서 수행되지 않는 기아 현상이
	발생할 수 있는데 이를 에이징 기법을 통해 해결한다. 
	에이징 기법은 시간이 지날수록 오래 대기한 프로세스의 우선순위를 높이는 방식
	다른 스케줄링 알고리즘과 결합해서 사용할 수 있어 선점, 비선점 모두 가능하다
- 스케줄러의 선점형(Preemptive)과 비선점형(Non-preemptive)의 차이는 무엇인가요?
	- 선점형 스케줄러
		하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음
	- 비선점형 스케줄러
		하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
	- 선점형과 비선점형 스케줄러의 차이
		- 비선점형
			프로세스가 자발적으로 blocked 상태로 들어가거나 실행이 끝났을 때만
			다른 프로세스로 교체 가능
		- 선점형
			프로세스 running 중에 스케줄러가 이를 중단시키고 다른 프로세스를 교체 가능
<br>

<h3>기타 주제</h3>

- 인터럽트란 무엇인가요? 종류에는 어떤 것들이 있나요?
	인터럽트란 프로세스 실행 도중 예기치 않은 상황이 발생할 때 발생한 상황을
	처리한 후 실행 중인 작업으로 복귀하는 것을 말한다.
	주로 입출력 장치의 signal, data가 발생할 때까지 원래의 작업을 수행하다가 
	해당 기능을 처리하는 것이다. (외부 인터럽트)
	
	- 비동기적 인터럽트 / 하드웨어 인터럽트
		전원 이상, 기계 착오, 외부 신호, 입출력 등 프로세스 외부에서 발생하는 인터럽트
	- 동기적 인터럽트 / 소프트웨어 인터럽트
		프로세스 내부에서 잘못된 명령어, 데이터로 exception이 발생한 것이며 trap이라고 불린다.
- 소프트웨어 인터럽트와 하드웨어 인터럽트의 차이는 무엇인가요?
	인터럽트의 원인과 발생 지점에서의 차이가 있다.
	- 소프트웨어 인터럽트
		원인 : 프로세스가 직접 실행 중에 특정 명령을 실행하여 인터럽트를 요청하는
		경우 발생한다. 주로 시스템 콜이나 예외 상황을 처리하기 위해 사용된다.
		
		발생 지점 : 사용자 프로그램 내에서 명시적으로 소프트웨어 인터럽트 명령을 
		실행할 때 발생한다.
	- 하드웨어 인터럽트
		원인 : 외부 장치나 하드웨어 이벤트에 의해 발생한다. 예를 들어, 
		타이머 인터럽트, I/O 장치에서의 데이터 도착, 하드웨어 에러 등이 해당된다.
		발생지점 : CPU는 외부에서 인터럽트를 받을 때 해당 인터럽트 서비스 루틴을
		실행하도록 프로세스를 일시 중단하고, 
		인터럽트 처리를 위해 인터럽트 서비스 루틴으로 제어를 전달한다.
	- 주요 차이점
		발생원인 : 
		소프트웨어 인터럽트는 프로세스 내에서 명시적으로 요청될 때 발생하며, 
		하드웨어 인터럽트는 외부 이벤트나 하드웨어 상태 변화에 의해 발생합니다.
		
		발생 지점 : 
		소프트웨어 인터럽트는 사용자 프로그램 내에서 명령어에 의해 발생하며, 
		하드웨어 인터럽트는 CPU가 하드웨어로부터 인터럽트 신호를 받을 때 
		발생합니다.
		
		예시 : 
		소프트웨어 인터럽트는 프로세스가 파일을 읽고 쓸 때의 시스템 호출과 관련이 
		있을 수 있고, 하드웨어 인터럽트는 키보드 입력, 타이머 인터럽트, 디스크 I/O 등의 하드웨어 이벤트에 관련이 있을 수 있습니다.
- I/O 바운드와 CPU 바운드의 차이는 무엇이며, 각각을 해결하는 방법은 무엇인가요?
	- Burst : 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것을 의미한다.
	- CPU Bound
		프로세스가 주로 CPU 연산에 많은 시간을 소비하는 경우
		계산이나 연산이 많은 작업에 적합한 상황
		CPU 사용률이 높고, I/O 작업은 상대적으로 적은 경우
		해결방법 : CPU 성능 향상이나 병렬 처리 등을 통해 성능을 개선 가능
	- I/O Bound 
		프로세스가 대부분의 시간을 대기하며 I/O 작업을 기다리는 경우
		주로 파일 입출력, 네트워크 통신, 데이터베이스 접근과 같은 입출력이 많은 상황
		CPU 사용률이 낮고, I/O 작업 대기 시간이 긴 경우 
		해결방법 : I/O 비동기화, 다중 스레딩 등을 통해 I/O 대기 시간을 최소화하거나 
		CPU 다중화를 통해 성능을 개선할 수 있다.
- 캐시의 동작 원리에 대해 설명해주세요.
	1. 캐시 레벨 
		일반적으로 시스템은 여러 수준의 캐시를 가진다. 
		레벨 1 (L1), 레벨 2 (L2), 레벨 3 (L3)
		레벨이 높아질수록 크기가 커지고 속도가 상대적으로 느려진다.
	2. 캐시 라인
		캐시는 데이터를 작은 블록 단위로 저장한다.
		이블록을 캐시 라인이라고 하며, 한 번에 전송되거나 캐시에 로드되는 
		최소 데이터 단위이다.
	3. 캐시 매핑 
		메모리 주소와 캐시 위치 간의 매핑 방법이 결정된다. 
		가장 일반적인 방법에는 집합 연관성 방식이 있으며, 직접 매핑, 
		연과 매핑, 세트 연관 매핑 등이 있다.
	4. 캐시 명령 
		데이터를 캐시로 읽기(캐시 미스 시), 쓰리, 갱신 등의 명령이 있다.
	5. 캐시 적중 및 캐시 미스
		캐시에서 데이터를 찾으면 캐시 적중이라고 하고 찾지 못하면 캐시 미스라고 한다.
		캐시 미스가 발생하면 해당 데이터를 주 메모리에서 읽어와 캐시에 로드한다.
	6. 캐시 교체 
		캐시가 가득 찬 경우, 어떤 데이터를 새로운 데이터로 교체할지 결정해야 한다.
		이를 위해 다양한 교체 알고리즘이 사용된다.
	7. 캐시 일관성
		다중 프로세서 시스템에서는 각 코어가 동일한 메모리 위치에 접근할 때 일관성을
		유지해야 한다. 캐시 일관성을 보장하기 위한 프로토콜이 사용된다.
- 가상 메모리와 캐시 메모리의 유사성과 차이는 무엇인가요?
	- 유사성
		1. 데이터 효율성 향상
			가상 메모리와 캐시 메모리는 각각 주 메모리 및 주 프로세서와의 속도 차이를 극복하고 성능을 향상시키는데 중점을 둔다.
		2. 임시 저장소
			둘 다 데이터를 일시적으로 저장하는 임시 메모리로 사용된다.
	- 차이
		1. 목적
			- 가상 메모리 : 프로그램이 필요로 하는 전체 메모리 공간을 물리적으로 
				확보하지 않고, 디스크나 다른 보조 기억 장치를 활용하여 프로그램 실행에 필요한 부분만 주 메모리에 로드하는 기술이다.
			- 캐시 메모리 : 데이터 및 명령을 주 메모리에서 더 빠르게 읽어오기 위해 주 메모리와 프로세서 사이에 위치한 고속 작은 메모리이다.
		2. 위치
			- 가상 메모리 : 디스크 등의 보조 기억장치에 위치하며, 주로 HDD나 SDD에 저장된다.
			- 캐시 메모리 : 주로 프러세서와 주 메모리 사이에 위치하며, CPU나 코어에 물리적으로 탑재된다.
		3. 동작 방식
			- 가상 메모리 : 주로 주 메모리와 디스크 간의 페이지 교환을 통해 동작하며, 필요한 부분만 주 메모리에 로드하여 사용된다.
			- 캐시 메모리 : 프로세서가 자주 참조하는 데이터 블록이나 명령을 주 메모리에서 읽어와 더 빠르게 엑세스할 수 있도록 동작하며, 데이터의 지역성에 기반한다. 
		- 요약 
			가상 메모리는 메모리 관의 효율성을 높이고 전체 프로그램을 실행하는 데 
			필요한 부분만 주 메모리에 로드하는 데 중점을 두는 반면, 
			캐시 메모리는 프로세서의 성능을 향상시키기 위해 주 메모리와 데이터 엑세스를 최적화 하는데 중점을 둔다.
- 리눅스와 윈도우 운영체제의 차이점은 무엇인가요?
	1. 소스 코드의 열린 여부
		- 리눅스 
			오픈 소스 운영체제로 소스 코드가 공개되어있고 커뮤니티에 의해
			개발 및 유지보수된다.
		- 윈도우
			프로프라이어터리 소프트웨어로, 소스 코드가 비공개이며, 
			마이크로스프트에 의해 개발되고 유지보수된다.
	2. 사용자 인터페이스
		- 리눅스
			주로 명령줄 인터페이스를 사용하며, 그래픽 사용자 인터페이스(GUI)를 
			사용하는 데에는 여러 환경이 있다. (예 : GNOME, KDE 등)
		- 윈도우 
			GUI 중심으로 설계되어 있으며, 사용자들은 주로 마우스 및 그래픽 환경을 통해 시스템을 조작한다.
	3. 하드웨어 호환성
		- 리눅스
			다양한 하드웨어 아키텍처를 지원하며, 경량 리눅스 배포판은
			리소스가 제한된 시스템에 적합하다.
		- 윈도우
			주로 x86 아키텍처를 위해 설계되어있으며, 다양한 하드웨어에 대한 
			지원이 있지만 리눅스만큼 다양하지 않다.
- 운영체제에서의 버퍼링과 스풀링의 차이점은 무엇인가요?
	- 버퍼링
		1. 목적
			데이터를 한곳에서 다른 곳으로 전송할 때, 일시적으로 
			데이터를 저장하여 전송의 효율성을 높이는 것이 목적
		2. 동작 방식
			입력이나 출력 장치 사이에서 데이터를 주고받을 때, 데이터를 일시적으로
			버퍼에 저장하고 필요에 따라 묶어서 전송함으로써 대역폭을 효과적으로 활용한다.
		3. 응용
			예를 들어, 파일을 복사하거나 네트워크를 통해 데이터를 전송할 때, 
			데이터를 버퍼에 저장하여 한 번에 전송함으로써 전체 프로세스의 성능을 
			향상시킨다.
	- 스풀링
		1. 목적 
			여러 프로세스 사이에서 공유 자원에 대한 효율적인 관리를 위해 사용된다.
			주로 출력 장치와의 상호작요에서 효과적으로 사용된다.
		2. 동작 방식 
			여러 작업이 출력 장치에 동시에 요청되었을 때, 이 작업들을 일시적으로 디스크의 스풀 공간에 저장하고 출력 장치가 이를 처리하도록 하는 방식이다.
		3. 응용 
			프린터 출력, 배치 작업 등에서 많이 사용된다. 여러 사용자가 프린터에 출력을
			요청해도 각각의 작업을 수풀링하여 순차적으로 프린터가 처리할 수 있도록 한다.
	- 요약
		- 공통점: 둘 다 데이터 처리를 효율적으로 관리하고 성능을 향상시키기 위한 목적을 가지고 있습니다.
		- 차이점: 버퍼링은 데이터 전송 시의 대역폭 효율화를 위해 사용되고, 스풀링은 여러 프로세스 간의 공유 자원(주로 출력 장치)을 관리하기 위해 사용됩니다.

			버퍼링은 입출력 장치 간의 데이터 효율적인 전송을 위한 것이며, 
			스풀링은 여러 프로세스 간의 출력 자원을 효율적으로 관리하기 위한 것입니다.