> **1. 메모리 영역이란 무엇인가?**

- 메모리 영역은 아래와 같이 구성됩니다. 
    - `Stack` : 데이터를 일시적으로 저장하는 공간으로, 데이터 영역과 다르게, 잠깐 쓰다가 말 값들이 저장되는 공간이다. 
    지역변수, 함수의 매개변수 (함수 실행 시 저장, 종료 시 반환)
    - `Heap` : 사용자가 프로그램을 실행하는 데 직접 할당하는 메모리 공간(런타임 간 저장, 원할 때 반환).
    - `Data`(and BSS) : 잠깐 읽고 끝낼게 아니라 계속 유지할 데이터, 예를 들어 `전역 변수`가 대표적으로 저장됩니다. 초기화된 변수(Data), 초기화 안 된 변수(BSS) (컴파일 시 저장, 프로그램 종료 시 반환)
    - `Code(or Text)` : 실행할 코드 (기계어로 이루어진 명령어)가 저장되는 공간으로 읽기 전용 공간입니다. (컴파일 시 저장, 프로그램 종료 시 반환)
- 코드 영역과 데이터 영역은 한 번 프로그램을 구성하면 바뀔 일이 없어서 크기가 고정된 영역이라는 의미로 **정적 할당 영역**이라고도 부릅니다. 
- 이에 반해, 실시간으로 그 크기가 변할 수 있기 때문에 **동적 할당 영역**이라고 부릅니다. 

<br>

> **2. 메모리 영역에서 힙/스택의 차이점이 무엇인가?**

- 일반적으로, 힙 영역은 메모리의 낮은 주소 -> 높은 주소로 할당되고, 스택 영역은 그 반대입니다.
- 만약 스택이 힙 영역을 침범하면 stack overflow, 그 반대면 heap overflow라고 부릅니다.

```
# JAVA로 힙/스택 비교

public class MemoryExample {
    public static void main(String[] args) {
        // 스택 영역: 지역 변수들이 할당되는 공간
        int x = 10; // 스택에 정수 변수 x가 생성됨
        int y = 20; // 스택에 정수 변수 y가 생성됨
        int result = add(x, y); // 스택에 정수 변수 result가 생성됨

        System.out.println("Result: " + result);

        // 힙 영역: 동적으로 할당된 객체가 저장되는 공간
        MyClass obj = new MyClass(42); // 힙에 MyClass 객체가 동적으로 생성됨
    }

    // 스택 영역: 메서드 호출 시 생성되는 스택 프레임에 매개변수가 할당됨
    private static int add(int a, int b) {
        return a + b; // 스택에 정수 변수가 생성되고 결과값이 반환됨
    }
}

// 힙 영역: 동적으로 할당되는 객체의 클래스 정의
class MyClass {
    private int value;

    public MyClass(int value) {
        this.value = value;
    }
}
```

- 데이터 영역 
    - 프로그램이 종료될 때까지 지워지지 않을 데이터 저장.
    - 대표적으로 전역 변수와 static 변수
    - 상수도 저장
- 스택 영역 
    - 잠깐 사용하고 삭제하는 데이터 저장(지역변수, 매개변수) 
    - 해당 객체가 정의된 블록(스코프)을 벗어날 때 소멸
    - 함수의 호출하는 위치도 저장.
    - 힙보다 빠름
- 힙 영역
    - 가비지 컬렉터가 없으면 프로그래머가 직접 관리(할당/해제)해줘야 함.
    - 스택보다 큰 메모리를 할당받기 위해 사용
    - 동적 메모리 할당 ( new /포인터)
    - delete를 사용하여 해당 객체 메모리 반환
    - 스택보다 느림

**2-1. 만약 힙 영역을 너무 크게 잡으면 어떻게 되는가?**

- 힙 영역은 스택과 다르게 직접 생성된 변수를 제거해주어 메모리 관리를 해야합니다. 만약, 힙 영역을 너무 크게 설정하면 그 만큼 GC의 수행시간이 너무 길어지게 됩니다. 따라서 Java의 JVM에서도 처음부터 힙 영역을 크게 잡지 않고, Heap 영역이 꽉 찼을 때 GC 진행 후 Heap 영역을 확장하게 됩니다.

<br>

> **3. IPC란 무엇인가?**

- 프로세스는 완전히 독립된 실행객체이다. 서로 독립되어 있다는 것은 다른 프로세스의 영향을 받지 않는다는 장점이 있다. 그러나 독립되어 있는 만큼 별도의 설비가 없이는 서로간에 통신이 어렵다는 문제가 있게 된다.

이를 위해서 커널 영역에서 IPC라는 내부 프로세스간 통신을 제공하게 되고, 프로세스는 커널이 제공하는 IPC설비를 이용해서 프로세스간 통신을 할 수 있게 된다.

IPC의 종류
1. 메시지 전달 (Message Passing)
커널이 제공하는 API를 이용해서 커널 공간을 통해 통신한다. 메시지 큐(Mesage Queue)를 사용하여 송신 프로세스는 큐에 enqueue, 수신 프로세스는 큐에 dequeue 하며 상호간 통신한다. 메시지 큐는 커널 단에서 관리된다.

파이프 (쉘에서 사용하는 그 파이프임)
소켓 (TCP/IP) - 로컬에서도 통신이 가능하며 원격에서도 통신이 가능하다. (IP : 127.0.0.1일 경우 로컬에서 패킷을 통해 프로세스끼리 통신하기도 한다.)

2. 메모리 공유 (Shared Memory)
프로세스끼리 특정 공통의 메모리 영역을 공유하며 상호간 통신하는 방법이다.

데이터 자체를 공유하도록 지원하며, 한 프로세스에서 변경한 메모리 공간의 내용을 다른 프로세스에서 접근할 수 있다. 공유 메모리는 커널에서 관리된다.

<br>

> **11. 동시성 대응 문제는 어떻게 해결하는지**

> **13. 컨텍스트 스위칭이 무엇인가?**

문맥교환(context switching)은, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스 혹은 쓰레드)의 상태를 PCB에 저장하고, 다음에 진행할 Task의 상태 값을 읽어 레지스터에 적재하는 과정을 의미합니다.

**13-1.컨텍스트 스위칭은 왜 해야 하는지?**

예를 들어, CPU Cycle의 속도는 I/O 작업에 비해 굉장히 빠릅니다. I/O 작업이 실행되고 Blocking 된다면, CPU는 아무런 일을 하지 않고 오랜 기간동안 쉬게 됩니다. 컨텍스트 스위칭을 통해 다른 프로세스나 쓰레드의 작업으로 전환한다면, CPU의 사용률을 높일 수 있습니다.

컨텍스트 스위칭을 진행하는 동안 다른 작업을 할 수 없는데(오버헤드), 보통 이 시간보다 I/O 작업이 더 오래 걸리기 때문에 컨텍스트 스위칭을 하는 것이 효율적입니다. 또한 컨텍스트 스위칭이 있기 때문에 여러 프로세스를 처리할 수 있습니다.

**13-2. 컨텍스트 스위칭이 일어나는 과정을 설명하시오**

- 1) CPU가 다른 프로세스로 전환하면 시스템은 프로세스의 상태를 PCB에 저장합니다.
- 2) 대기열에서 다음 프로세스를 선택하고 해당 프로세스의 PCB를 복원합니다.
- 3) PCB의 프로그램 카운터(레지스터)가 로드되어 이전까지 작업한 곳의 지점으로 돌아가 선택한 프로세스의 작업을 이어서 합니다.



> **14.버츄얼 메모리란 무엇인가?**

- 물리적 메모리보다 더 큰 프로그램이 실행될 수 있도록 컴퓨터 시스템에서 사용하는 메모리 관리 기법입니다.

**14-1. virtual address를 physical address로 변환하는 방법은?**

- CPU가 메모리 참조를 실행할 때는 MMU(Memory Management Unit)라는 HW 장치를 이용해 해당 가상 주소를 실제 메인 메모리의 물리 주소로 변환하여 메모리 참조를 진행합니다.

**14-2. 가상 메모리는 왜 필요한가?**

- 먼저, 메인 메모리를 효율적으로 사용할 수 있습니다. 가상 메모리 시스템에서는 각 프로그램이 사용하는 가상 주소 공간을 우선 디스크에 저장해두고, 그중에서 자주 사용되는 부분만 메인 메모리로 가져와서 사용됩니다.
- 다음으로, 메모리 관리를 단순화합니다. 가상 메모리 시스템에서는 각 프로세스가 완전히 동일한 포맷의 가상 주소 공간을 가집니다. 이것이 가능한 이유는 실제로 메모리 참조를 수행할 때는 가상 주소를 물리 주소로 변환하는 작업이 진행되기 때문입니다.
- 마지막으로, 메모리 보호 메커니즘을 단순화합니다. 가상 메모리 시스템에서는 다른 프로세스의 주소 공간이 접근하는 것을 쉽게 막을 수 있습니다.

> **20.CPU스케쥴링 알고리즘**