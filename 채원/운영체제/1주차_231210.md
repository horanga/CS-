<h1>1주차(12월 10일)</h1>

<h2>운영체제 CS 면접</h2>

<br>

> **1. 운영체제가 무엇인지 설명하시오**

**운영체제(OS: Operating System)** 란 컴퓨터 하드웨어를 관리하고, 응용 프로그램과 하드웨어 간의 인터페이스 역할을 하는 시스템 소프트웨어입니다. 주요 기능으로는 자원 관리, 작업 스케줄링, 메모리 관리, 파일 시스템 관리 등이 있습니다.

```
프로그램(소프트웨어)
=> 크게 운영체제 / 응용프로그램(= Application, App)으로 구분
=> 운영체제는 응용프로그램을 관리해 사용자가 사용하기 편하게 도와줌
```

<br>

**1-1. 운영체제의 기능은 무엇인가**
- 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리
- 자원을 효율적으로 관리하기 위해 자원의 스케쥴링 기능을 제공
- 사용자와 시스템간의 편리한 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리, 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류를 검사하고 복구
- 자원 보호 기능을 제공
- 입출력에 대한 보조 기능을 제공
- 가상 계산기 능력을 제공


**1-2. 운영체제의 목적은 무엇인가?**
- 처리능력 향상
- 사용 가능도 향상
- 신뢰도 향상
- 반환 시간 단축


**1-3. 운영체제의 구성은 어떻게 되는가?**
- 제어 프로그램 : 컴퓨터 안의 정보들과 자원을 제어, 상태를 감시하고 실행하는 과정을 지시하고 관리
- 처리 프로그램 : 실제로 데이터 처리를 실행하고 결과를 보여줌


<br>

> **2. 프로세스와 스레드의 차이에 대해서 설명하시오**

첫 번째로, 자원 공유면에서는 각 프로세스는 독립적인 메모리 공간을 가지기 때문에, 프로세스 간에 직접적인 메모리 공유가 어렵습니다. 만약 프로세스간 메모리 공유가 필요하다면, 프로세스 간 통신(IPC)을 사용하여 데이터를 교환해야 한다. 이에 반해, 스레드는 하나의 프로세스 내에서 실행되기 때문에, 스레드 간에는 직접적으로 메모리를 공유할 수 있습니다. 하지만 이로 인해 동기화 문제가 발생할 수 있으므로 주의가 필요합니다. 

두 번째로, 생명 주기면에서는 프로세스는 독립적인 실행 단위이므로 각각이 독립적인 생명 주기를 가집니다. 즉, 프로세스의 생성, 실행, 종료 등은 서로 독립적으로 관리됩니다. 이에 반해, 스레드는 하나의 프로세스 내에서 실행되는 작은 실행 단위이므로, 프로세스의 일부로 존재하며 프로세스의 생명 주기에 종속됩니다. 

세 번째로 오버헤드면에서는 프로세스는 프로세스 간 전환에는 상대적으로 더 많은 오버헤드가 발생합니다. 프로세스 간에는 컨텍스트 스위칭이 필요하고, IPC를 통한 통신도 비용이 큽니다. 이에 반해, 스레드 간 전환은 프로세스 간 전환보다 적은 오버헤드를 가집니다. 스레드는 같은 주소 공간에서 실행되므로 컨텍스트 스위칭이 더 효율적입니다.

<br>

**2-1. 프로세스란 무엇인가?**

- 컴퓨터에서 실행되고 있는 프로그램을 의미하며, 운영 체제 프로세스와 사용자 프로세스로 나뉜다.
- 각 프로세스는 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)를 할당받는다.
- 기본적으로 1개의 프로세스 당 최소 1개의 스레드를 갖는다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)를 사용해야 한다.

**2-2. 스레드란 무엇인가?**

- 스레드는 CPU 사용의 기본 단위로, 프로세스 내에서 실행되는 여러 흐름의 단위를 말한다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 세트 및 스택으로 구성된다.
- OS는 자원을 효율적으로 사용하려고 한다. 스레드를 사용하면 프로세스보다 생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적다. 또한 병렬성도 높일 수 있다.
- 스레드는 프로세스 내에서 각각 stack만 따로 할당받고 code, data, heap 영역은 공유한다.
- 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레시스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

**2-3. 스레드의 장점은 무엇인가?**

- 스레드는 프로세스보다 생성 및 종료시간, 스레드간 전환시간이 짧다.
- 스레드는 프로세스의 메모리, 자원 등을 공유하므로 커널의 도움없이 상호간의 통신이 가능하다.

**2-4. 멀티 스레딩의 장점과 단점은 무엇인가?**

- 멀티 스레딩이랑 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것을 의미한다.
- 장점) 하나의 프로세스 내에 다수의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 줄일 수 있다.
- 단점) 교착상태를 발생시킬 수 있으며, 동기화에 주의해야 한다.

**2-5. 스레드의 동기화, 동시성 제어에 주의해야 하는 이유는 무엇인가?**

- 스레드의 동기화 문제는 여러 스레드가 공유된 데이터 또는 자원에 동시에 접근할 때 발생할 수 있는 문제를 가리킵니다. 여러 스레드가 동시에 데이터를 변경하려고 할 때 예측할 수 없는 결과가 발생할 수 있으며, 이로 인해 프로그램이 예상치 못한 동작을 할 수 있습니다. 
- 경쟁 상태 (Race Condition): 여러 스레드가 공유된 자원에 동시에 접근하여 값을 변경하려고 할 때 발생합니다. 결과적으로 스레드 간의 실행 순서에 따라 예상치 못한 값이 나올 수 있습니다.
- 교착 상태 (Deadlock): 두 개 이상의 스레드가 서로가 가진 자원을 대기하며 무한히 기다리는 상태입니다. 각 스레드는 다른 스레드가 가진 자원을 요청하며 서로가 가진 자원을 놓지 않아 발생할 수 있습니다.
- 데드락 (Livelock): 스레드가 서로의 행동에 반응하여 무한히 반복되는 상태를 가리킵니다. 데드락은 교착 상태와 유사하지만 스레드는 활동하며 서로에게 영향을 주기 때문에 실질적으로는 진행이 없습니다.
- 순서 문제 (Ordering Problem): 스레드 간의 실행 순서에 따라 결과가 달라지는 문제로, 이로 인해 의도치 않은 동작이 발생할 수 있습니다.
- 동기화 문제를 해결하기 위해 동기화 메커니즘과 기법이 사용됩니다. 주요 동기화 기법으로는 뮤텍스(Mutex), 세마포어(Semaphore), 조건 변수(Condition Variable) 등이 있습니다. 이러한 기법을 사용하여 스레드 간의 상호배제, 교착 상태 방지, 순서 제어 등을 구현하여 안전하고 예측 가능한 다중 스레드 환경을 만들 수 있습니다.

**2-6. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇인가?**

- 멀티 프로세스를 사용하면 프로세스 간의 context switching시 CPU 레지스터 뿐 아니라 ram, cpu 사이의 캐시 메모리에 대한 데이터까지 모두 초기화 되어 오버헤드가 크나, 스레드는 프로세스 내의 메모리를 공유하기 때문에 스레드간 데이터를 주고받는 것이 간단해지기 때문이다.
- 또한,프로세스간 통신(IPC)보다 스레드 간의 통신 비용이 적기 때문에 작업들 간의 통신 부담이 줄어들며, 전환 속도 또한 빠르다(context switching시 stack 영역만 처리하기 때문에).

**2-7. 메모리 구조를 영역에 따라 설명하시오.**

- 메모리는 크게 코드, 데이터, 힙, 스택 영역으로 구분된다. 
- `코드 영역`은, 실행할 프로그램의 기계어 코드가 저장되는 영역으로, '텍스트' 영역이라고도 부릅니다. CPU는 해당 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
- `데이터 영역`은 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 시작하는 동시에 할당되며, 프로그램이 종료되면 소멸합니다.
   - 전역 변수 : 프로그램 내에서 어디서든 접근할 수 있는 변수. 이 변수는 프로그램의 어느 부분에서도 선언되고 초기화되며 사용될 수 있음.
   - 정적 변수 :  특정 함수나 블록 내에서 선언되지 않고, 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료될 때까지 존재하는 변수)
- `힙 영역`은, 동적으로 할당된 메모리가 저장되는 영역입니다. 프로그램 실행 중에 필요한 크기의 메모리를 동적으로 할당하고 해제할 수 있습니다. 힙은 프로그래머가 메모리를 직접 관리해야 하는 영역이며, 메모리 누수 등의 문제가 발생할 수 있습니다.
- `스택 영역`은, 함수의 호출에 따른 지역변수와 매개변수가 저장되는 영역으로, 컴파일 시 크기가 결정됩니다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 소멸합니다.

**2-8. IPC란 무엇인가?**

- 커널 영역에서 IPC를 사용하여 프로세스들 간에 통신을 제공한다.
- Pipe : 2개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 한다.
- Message Queue : FIFO 자료구조를 가지는 통신 설비로 커널에서 관리한다. 장점은 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다. 단점은 데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다.
- Shared memory : 프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에 메모리 공간을 할당해주고 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다. 장점은 중개자 없이 곧바로 메모리에 적용할 수 있기 때문에 모든 IPC 중 가장 빠르다. 단점은 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없습니다.

<br>

> **3. 시스템 호출에 대해서 설명하시오**

사용자 모드로 실행되는 프로그램이 운영체제 서비스를 제공받으려면 운영체제에게 요청을 보내 커널 모드로 전환이 되야하는데, 이렇게 운영체제의 서비스를 받기 위한 요청을 의미합니다. 주로, 프로세스 관리, 파일 입출력, 파일 시스템 관리 등의 기능을 호출할 수 있습니다.

**3-1. 사용자 모드와 커널 모드(혹은 이중 모드)란 무엇인가? 또한 왜 그렇게 모드가 나뉘는가?**
   - 사용자 모드
      - 운영체제 서비스를 제공받을 수 없는 실행 모드. 즉, 커널 영역의 코드를 실행할 수 없는 모드.
      - 일반적인 응용 프로그램이 실행되는 모드.
   - 커널 모드 
      - 운영체제 서비스를 제공받을 수 있는 실행 모드. 즉, 커널 영역의 코드를 실행할 수 있는 모드.
      - 운영체제가 실행되는 모드. 
   - CPU에 직접적으로 응용 프로그램이 접근하면 자원이 무질서하게 관리될 것이고, 조금만 실수해도 컴퓨터 전체에 악영향이 가는데, 이 때, 운영체제가 응용 프로그램들이 자원에 직접 접근하는 것을 막고 자원의 효율적인 운영을 유지하기 위해서.

**3-2. 시스템 호출의 예시를 들어 설명하시오**

- 순서는 아래와 같다. 
   - 1. 사용자 프로그램의 호출
   - 2. 라이브러리 함수 호출
   - 3. 라이브러리 함수 내부에서의 시스템 콜 호출
   - 4. 커널 모드에서의 처리
   - 5. 커널에서 사용자 모드로 반환

```
# 파일을 열어 읽기 모드로 데이터를 읽어오는 예제

with open("example.txt", "r") as file:
    data = file.read()
```

- 만약 이러한 코드가 있다고 치면 
   - 위의 코드를 실행(**1번 실행**),
   - `open()`함수는 라이브러리 함수이므로, 내부적으로 시스템 콜을 호출한다. 함수 내부에서 시스템 콜을 호출하기 위해 CPU는 사용자 모드에서 커널 모드로 전환(**2번&3번 실행**).
   - 커널 모드에서는 운영체제의 핵심 기능을 수행. open() 시스템 콜의 경우, 파일을 열기 위한 커널의 루틴이 실행(**4번 실행**).
   - 운영체제의 기능을 처리한 후, CPU는 다시 사용자 모드로 전환되어 사용자 프로그램에 제어를 반환합니다. open() 함수는 파일 디스크립터를 반환받아 사용자 프로그램으로 복귀(**5번 실행**)

**3-3. 시스템 콜의 종류에는 어떤 것이 있는가?**

- 주로 아래와 같은 것들이 사용된다. 
- fork() 및 exec() (프로세스 생성 및 실행):
   - fork(): 새로운 프로세스를 생성합니다. 부모 프로세스와 자식 프로세스가 동일한 코드를 공유하지만 각자 별도의 메모리 공간을 가지게 됩니다.
   - exec(): 새로운 프로그램을 현재 프로세스의 메모리에 로드하고 실행합니다.
- open(), read(), write(), close() (파일 입출력):
   - open(): 파일을 엽니다.
   - read(): 파일로부터 데이터를 읽습니다.
   - write(): 파일에 데이터를 씁니다.
   - close(): 파일을 닫습니다.
- exit() 및 wait() (프로세스 종료 및 대기):
   - exit(): 현재 프로세스를 종료합니다.
   - wait(): 부모 프로세스가 자식 프로세스의 종료를 기다립니다.
- malloc() 및 free() (동적 메모리 할당 및 해제):
   - malloc(): 동적으로 메모리를 할당합니다.
   - free(): 할당된 메모리를 해제합니다.
- socket(), bind(), connect(), send(), recv() (네트워크 통신)

<br>

> **커널의 개념을 설명하시오**

**커널(Kernel)**: 커널은 OS의 핵심으로 자원에 접근하고 조작하는 기능이나 프로그램이 올바르고 안전하게 실행되게 하는 기능 등을 담당하는 부분입니다. 

OS 또한 프로그램 중 하나이기 때문에 이것이 실행되려면 RAM에 적재되어있어야 합니다. 하지만, OS를 모두 RAM에 올리기에는 메모리 공간의 낭비가 있으므로, 항상 필요한 운영체제의 핵심 부분만을 메인 메모리에 적재하여 운영체제를 사용하게끔 합니다.

즉, 커널은 메모리에 상주하는 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간 통신을 담당합니다. 주요 기능은 프로세스 스케줄링, 메모리 관리, 입출력 관리 등이며, 시스템 호출을 처리하는 역할을 합니다. 커널은 운영체제의 핵심 모듈로서 하드웨어를 직접 제어하고, 응용 프로그램에 필요한 서비스를 제공합니다.