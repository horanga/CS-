### 1.IDE(통합개발환경)에서 컴파일하는 것과 커널 모드의 관계를 설명하시오

* * *

    우리가 사용하는 프로그래밍 언어로 명령어를 작성하면 이에 알맞는 메모리 자원을 할당해야 한다. c언어 같은 경우는 메모리를 할당받은 뒤 
    해당 구문이 더는 필요하지 않다면 free()를 처리해서 자원을 반납해준다고 한다. java와 같은 언어는 GC(Garbage Collection)을 지원하면서
    이용자가 직접 사용하지 않는 메모리를 반납하지 않도록 하고 있다.

    c언어는 메모리를 할당할 때 malloc같은 명령어를 수행하는데, 원래 특정 프로세스에 메모리를 할당하는 것은 운영체제의 역할이다. malloc를 수행하면
    내부적으로 시스템이 콜이 발생해서 운영체제에 메모리 할당을 요청하는 것이다.

    cf)프로세스는 일반적인 사용자모드와 PC의 주요 하드웨어 자원을 사용할 수 있는 커널모드를 왔다갔다 한다. 시스템콜이 발생하면,
    운영체제가 커널모드를 실행해서 프로세스에 하드웨어 자원을 할당한다. 참고로, 컴파일은 프로그래밍 언어를 커널이 이해할 수 있게 변환시켜주는 작업이라고 이해했다.

    c언어는 포인터를 통해서 메모리에 직접 접근할 수 있는데, 이 구조 덕분에 시스템콜을 다이렉트로 발생시킬 수 있다고 한다.(malloc는 시스템콜 자체가 아니라 
    시스템콜을 사용하는 API라고 함)
    반면, java는 시스템 콜을 간접적으로 사용한다.

    I/O가 발생하는 예시를 들어보자. C프로세스는 시스템 콜을 요청하고, 커널모드로 가서 디스크 컨트롤러를 통해 데이터를 복사한다. 
    자바는 JVM -> JNI(Java Native Interface) -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사 흐름으로 작동한다.
    내 생각엔 System.out.println같은 코드가 시스템 호출을 사용할 때 쓰는 API인것 같다! 이를 통해 JVM은 콘솔에 텍스트를 출력하기 위해 운영체제의 파일 또는 스트림 쓰기 기능에 접근해야 한다고 한다.
    개발자는 운영체제의 복잡한 파일 시스템이나 콘솔 관리 기능을 직접 다룰 필요 없이 간편하게 출력할 수 있다.

코드를 작성할 때 막연하게 메모리를 적게 사용하는 방식이 좋다는 정도로만 이해했었다. 알고리즘 문제 사이트들을 보면 컴파일 때 메모리를 체크하던데 실제로 메모리자원을 효율적으로 사용하는지
체크하기 위해서였다는 걸 이제 정확하게 이해했다.




__참고자료 https://brewagebear.github.io/java-syscall-and-io/__

### 2.CPU 스케쥴링은 서버 성능에 어떻게 영향을 미치는지 설명하시오

* * *

    CPU스케쥴링은 프로세스에 CPU 자원을 할당하는 정책을 말한다. 프로세스들에게 현명하게 CPU를 배분하지 못하면 반드시 실행돼야 할 프로세스가 실행되지 못하거나,
    당장 급하지 않은 프로세스들만 주로 실행되는 것처럼 무질서한 상태가 발생할 수 있다. 운영체제는 프로세스마다 PCB(Process Control Block)에 우선순위를 명시해서 먼저 처리할 프로세스를 정한다.

    주로 입출에 집중된 프로세스들이 우선순위가 높은 프로세스에 속한다. 이 프로세스는 CPU 집중 프로세스와 달리 CPU를 많이 사용하지 않는다. CPU집중 프로세스와 입출력 집중 프로세스가
    동시에 CPU자원을 요구했다고 가정해보자. 이때, 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력장치를 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당시키는 것이다.
    쉽게 생각하면, 입출력 집중 프로세스는 짧게 CPU 조금 쓰고 그 다음부터는 계속 입출력장치를 쓴다. 입출력장치를 쓰는 동안에는 이 CPU를 놀리지 않고 다른 프로세스에 할당할 수 있다.

    +입출력 집중 프로세스를 먼저 쓰면 좋은 또 다른 이점으로는 이용자 경험을 향상시킬 수 있다는 것이다. 이용자 입장에서는 디스플레이에 결과물이 더 빨리 뜨니까.

    PCB에 우선순위가 적혀 있지만, CPU를 사용할 프로세스를 찾기 위해서 모든 프로세스의 PCB를 확인하는 것은 비효율적이다. 그래서, 운영체제는 프로세스에게 '줄을 서서 기다려라'라고 요구한다.   
    그리고, 운영체제는 이 줄을 '스케쥴링 큐'로 구현해서 관리한다.(여기서 큐는 일반적인 자료구조처럼 선입선출의 방식일 필요는 없다고 한다) 
    대표적인 큐로는 준비큐(ready queue, CPU를 이용하고 싶은 프로세스가 서는 줄)와 대기큐(waiting queue, 입출력장치를 쓰려는 프로세스들이 서는 줄)가 있다.

    *우선순위가 높은 프로세스가 큐의 맨 앞에 있지 않더라도 먼저 처리될 수 있다. 우선순위는 마치 특별혜택을 받는 VIP와 같은 것이다.

    스케쥴링 방식에는 1)선점형 스케쥴링 2)비선점형 스케쥴링이 있다. 선점형 스케쥴링은 지금 CPU를 사용하고 있는 프로세스로부터 CPU 자원을 빼았아 다른 프로세스에 할당하는 방식이다.
    프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 다 써서 타임 인터럽트가 발생하고 운영체제가 CPU를 회수하는 것이 대표 사례다.
    비선점형 스케쥴링은 하나의 프로세스가 CPU자원을 사용하고 있으면 종료되거나, 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들지 못하는 방식을 말한다. 
    (현재 대부분의 운영체제는 선점형 스케쥴링을 사용하는데, 단점은 문맥 교환과정에서 오버헤드가 발생할 수 있다는 것이다)

    스케쥴링이 서버 성능에 직접적으로 영향을 미치는 부분은 특정 알고리즘의 장점들을 살펴봐야 한다. 
    스케쥴링의 기준이라는 것이 있는데, 대표적으로 처리량과 응답시간 자원활용 대기시간 우선순위 공정성이 있다. 

    처리량을 기준으로 하면, 처리 시간이 짧은 것들을 먼저 처리해서 시간당 작업량을 늘릴 수 있다. 응답시간을 기준으로 하면, 모든 프로세스에 공평한 시간동안 CPU를 할당해서 다음 프로세스가   
    오래 기다리지 않도록 할 수 있다.

    좀더 구체적인 예를 들면, 배치 처리 시스템에서는 가능한 많은 작업을 완료하는 게 중요하므로 처리량을 늘리는 것이 더 중요하다. 그래서 처리 시간이 짧은 작업부터 먼저 처리해서 전체 처리량을 늘릴 수 있다.
    대화형 시스템에서는 사용자 질의에 빠르게 응답하는 것이 중요하므로 응답시간을 최소화하는 알고리즘이 필요하다. 
    특정 스케쥴링 알고리즘이 모든 목표에서 최적이 될 수는 없으니 목표에 따라 적절한 알고리즘을 쓰는 게 중요할 거 같다.

__참고자료 -혼자 공부하는 컴퓨터구조+운영체제(강민철 지음)__