<h1>1주차(12월 10일)</h1>

<h2>운영체제 CS 면접</h2>

<br>

> <b>운영체제가 무엇인지 설명하시오</b>

<b>운영체제(OS: Operating System)</b>란 컴퓨터 하드웨어를 관리하고, 응용 프로그램과 하드웨어 간의 인터페이스 역할을 하는 시스템 소프트웨어입니다. 주요 기능으로는 자원 관리, 작업 스케줄링, 메모리 관리, 파일 시스템 관리 등이 있습니다.

```
프로그램(소프트웨어)
=> 크게 운영체제 / 응용프로그램(= Application, App)으로 구분
=> 운영체제는 응용프로그램을 관리해 사용자가 사용하기 편하게 도와줌
```

<br>

<b>1. 운영체제의 기능</b>
- 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리
- 자원을 효율적으로 관리하기 위해 자원의 스케쥴링 기능을 제공
- 사용자와 시스템간의 편리한 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리, 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류를 검사하고 복구
- 자원 보호 기능을 제공
- 입출력에 대한 보조 기능을 제공
- 가상 계산기 능력을 제공


<b>2. 운영체제의 목적</b>
- 처리능력 향상
- 사용 가능도 향상
- 신뢰도 향상
- 반환 시간 단축


<b>3. 운영체제의 구성</b>
- 제어 프로그램 : 컴퓨터 안의 정보들과 자원을 제어, 상태를 감시하고 실행하는 과정을 지시하고 관리
- 처리 프로그램 : 실제로 데이터 처리를 실행하고 결과를 보여줌


<br>

> <b>프로세스와 스레드의 차이에 대해서 설명하시오</b>

첫 번째로, 자원 공유면에서는 각 프로세스는 독립적인 메모리 공간을 가지기 때문에, 프로세스 간에 직접적인 메모리 공유가 어렵습니다. 만약 프로세스간 메모리 공유가 필요하다면, 프로세스 간 통신(IPC)을 사용하여 데이터를 교환해야 한다. 이에 반해, 스레드는 하나의 프로세스 내에서 실행되기 때문에, 스레드 간에는 직접적으로 메모리를 공유할 수 있습니다. 하지만 이로 인해 동기화 문제가 발생할 수 있으므로 주의가 필요합니다. 

두 번째로, 생명 주기면에서는 프로세스는 독립적인 실행 단위이므로 각각이 독립적인 생명 주기를 가집니다. 즉, 프로세스의 생성, 실행, 종료 등은 서로 독립적으로 관리됩니다. 이에 반해, 스레드는 하나의 프로세스 내에서 실행되는 작은 실행 단위이므로, 프로세스의 일부로 존재하며 프로세스의 생명 주기에 종속됩니다. 

세 번째로 오버헤드면에서는 프로세스는 프로세스 간 전환에는 상대적으로 더 많은 오버헤드가 발생합니다. 프로세스 간에는 컨텍스트 스위칭이 필요하고, IPC를 통한 통신도 비용이 큽니다. 이에 반해, 스레드 간 전환은 프로세스 간 전환보다 적은 오버헤드를 가집니다. 스레드는 같은 주소 공간에서 실행되므로 컨텍스트 스위칭이 더 효율적입니다.


<b>프로세스(Process)</b>: 독립적으로 메모리 공간을 할당받아 실행 중인 프로그램의 인스턴스를 의미합니다. 각 프로세스는 자체 주소 공간, 파일, 레지스터 등을 가지며, 프로세스 간 통신을 위해 IPC(Inter-Process Communication)이 필요합니다.

<b>스레드(Thread)</b>: 경량화된 프로세스로, 하나의 프로세스 내에서 실행되는 여러 흐름 단위를 말합니다. 스레드는 프로세스의 자원을 공유하며, 스레드 간 데이터 공유가 비교적 쉽습니다. 하지만 동시성 제어에 주의해야 합니다.

멀티 스레드를 사용하면, 멀티 프로세스로 진행되는 작업보다 시스템콜이 줄어들기 때문에, 자원을 효율적으로 관리할 수 있고, 프로세스간의 통신비용보다 스레드간의 통신비용이 적습니다. 

<br>

<b>1. 프로세스란 무엇인가?</b>

- 컴퓨터에서 실행되고 있는 프로그램을 의미하며, 운영 체제 프로세스와 사용자 프로세스로 나뉜다.
- 각 프로세스는 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)를 할당받는다.
- 기본적으로 1개의 프로세스 당 최소 1개의 스레드를 갖는다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)를 사용해야 한다.

<b>2. 스레드란 무엇인가?</b>

- 스레드는 CPU 사용의 기본 단위로, 프로세스 내에서 실행되는 여러 흐름의 단위를 말한다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 세트 및 스택으로 구성된다.
- OS는 자원을 효율적으로 사용하려고 한다. 스레드를 사용하면 프로세스보다 생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적다. 또한 병렬성도 높일 수 있다.
- 스레드는 프로세스 내에서 각각 stack만 따로 할당받고 code, data, heap 영역은 공유한다.
- 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레시스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

<b>3. 스레드의 장점은 무엇인가?</b>

- 스레드는 프로세스보다 생성 및 종료시간, 스레드간 전환시간이 짧다.
- 스레드는 프로세스의 메모리, 자원 등을 공유하므로 커널의 도움없이 상호간의 통신이 가능하다.

<b>4. 멀티 스레딩의 장점과 단점은 무엇인가?</b>

- 멀티 스레딩이랑 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것을 의미한다.
- 장점) 하나의 프로세스 내에 다수의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 줄일 수 있다.
- 단점) 교착상태를 발생시킬 수 있으며, 동기화에 주의해야 한다.

<b>4-1. 스레드의 동기화, 동시성 제어에 주의해야 하는 이유는 무엇인가?</b>

- 스레드의 동기화 문제는 여러 스레드가 공유된 데이터 또는 자원에 동시에 접근할 때 발생할 수 있는 문제를 가리킵니다. 여러 스레드가 동시에 데이터를 변경하려고 할 때 예측할 수 없는 결과가 발생할 수 있으며, 이로 인해 프로그램이 예상치 못한 동작을 할 수 있습니다. 
- 경쟁 상태 (Race Condition): 여러 스레드가 공유된 자원에 동시에 접근하여 값을 변경하려고 할 때 발생합니다. 결과적으로 스레드 간의 실행 순서에 따라 예상치 못한 값이 나올 수 있습니다.
- 교착 상태 (Deadlock): 두 개 이상의 스레드가 서로가 가진 자원을 대기하며 무한히 기다리는 상태입니다. 각 스레드는 다른 스레드가 가진 자원을 요청하며 서로가 가진 자원을 놓지 않아 발생할 수 있습니다.
- 데드락 (Livelock): 스레드가 서로의 행동에 반응하여 무한히 반복되는 상태를 가리킵니다. 데드락은 교착 상태와 유사하지만 스레드는 활동하며 서로에게 영향을 주기 때문에 실질적으로는 진행이 없습니다.
- 순서 문제 (Ordering Problem): 스레드 간의 실행 순서에 따라 결과가 달라지는 문제로, 이로 인해 의도치 않은 동작이 발생할 수 있습니다.
- 동기화 문제를 해결하기 위해 동기화 메커니즘과 기법이 사용됩니다. 주요 동기화 기법으로는 뮤텍스(Mutex), 세마포어(Semaphore), 조건 변수(Condition Variable) 등이 있습니다. 이러한 기법을 사용하여 스레드 간의 상호배제, 교착 상태 방지, 순서 제어 등을 구현하여 안전하고 예측 가능한 다중 스레드 환경을 만들 수 있습니다.

<b>5. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇인가?</b>

- 멀티 프로세스를 사용하면 프로세스 간의 context switching시 CPU 레지스터 뿐 아니라 ram, cpu 사이의 캐시 메모리에 대한 데이터까지 모두 초기화 되어 오버헤드가 크나, 스레드는 프로세스 내의 메모리를 공유하기 때문에 스레드간 데이터를 주고받는 것이 간단해지기 때문이다.
- 또한,프로세스간 통신(IPC)보다 스레드 간의 통신 비용이 적기 때문에 작업들 간의 통신 부담이 줄어들며, 전환 속도 또한 빠르다(context switching시 stack 영역만 처리하기 때문에).

<b>6. 메모리 구조를 영역에 따라 설명하시오.</b>

- 메모리는 크게 코드, 데이터, 힙, 스택 영역으로 구분된다. 
- `코드 영역`은, 실행할 프로그램의 기계어 코드가 저장되는 영역으로, '텍스트' 영역이라고도 부릅니다. CPU는 해당 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
- `데이터 영역`은 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 시작하는 동시에 할당되며, 프로그램이 종료되면 소멸합니다.
   - 전역 변수 : 프로그램 내에서 어디서든 접근할 수 있는 변수. 이 변수는 프로그램의 어느 부분에서도 선언되고 초기화되며 사용될 수 있음.
   - 정적 변수 :  특정 함수나 블록 내에서 선언되지 않고, 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료될 때까지 존재하는 변수)
- `힙 영역`은, 동적으로 할당된 메모리가 저장되는 영역입니다. 프로그램 실행 중에 필요한 크기의 메모리를 동적으로 할당하고 해제할 수 있습니다. 힙은 프로그래머가 메모리를 직접 관리해야 하는 영역이며, 메모리 누수 등의 문제가 발생할 수 있습니다.
- `스택 영역`은, 함수의 호출에 따른 지역변수와 매개변수가 저장되는 영역으로, 컴파일 시 크기가 결정됩니다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 소멸합니다.

<b>7. IPC란 무엇인가? </b>

- 커널 영역에서 IPC를 사용하여 프로세스들 간에 통신을 제공한다.
- Pipe : 2개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 한다.
- Message Queue : FIFO 자료구조를 가지는 통신 설비로 커널에서 관리한다. 장점은 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다. 단점은 데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다.
- Shared memory : 프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에 메모리 공간을 할당해주고 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다. 장점은 중개자 없이 곧바로 메모리에 적용할 수 있기 때문에 모든 IPC 중 가장 빠르다. 단점은 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없습니다.

<br>

> <b>시스템 호출에 대해서 설명하시오</b>

<b> 시스템 호출(System Call)</b>: 운영체제의 서비스를 이용하기 위해 응용 프로그램이 운영체제 커널에게 요청하는 인터페이스입니다. 주로 파일 입출력, 프로세스 생성과 종료, 메모리 할당, 네트워크 통신 등의 기능을 호출할 수 있습니다. 시스템 호출은 일반적으로 어셈블리어 수준에서 이루어지며, 사용자 프로그램과 운영체제 간의 경계를 정의합니다.

CPU는 사용자 애플리케이션 (User application)이 시스템을 손상시키는 것을 방지하기 위해 2가지 모드를 제공한다. CPU에 있는 Mode bit로 모드를 구분하여 0은 커널모드(kernel mode), 1은 사용자모드 (user mode)로 나뉘어서 구동된다.

운영체제에서 프로그램이 구동되는데 있어서 파일을 읽어오거나, 파일을 쓰거나, 혹은 화면에 메세지를 출력하는 등 많은 부분이 커널 모드를 사용한다.

🔸 사용자 모드 (User Mode)
사용자 모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근할 수 없다. 접근을 위해서는 '시스템 콜(System Call)'을 사용해야 한다. 사용자 애플리케이션의 각 스레드들은 고유의 사용자 모드 스택을 갖는다.

🔸 커널 모드 (Kernel Mode)
운영체제(OS)가 CPU를 사용하는 모드이다. 시스템 콜을 통해 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어(Privileged Instructions)를 실행한다. Privileged Instructions는 사용자 모드에서 실행되면 exception이 발생한다.

OS는 다양한 서비스들을 수행하기 위해 하드웨어를 직접적으로 관리한다. 이에 반해, 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다. OS가 제공하는 이러한 인터페이스를 '시스템 콜 (system call)' 이라고 한다.

시스템콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉, 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 할 수 있게 해준다. (즉, 응용프로그램은 시스템 콜을 사용해서 원하는 기능을 수행할 수 있음.)

보통 직접적으로 시스템콜을 사용하기 보다는 API(라이브러리 함수)를 통해 사용하게 된다.

🔸 시스템콜 종류
시스템콜은 크게 6가지로 분류할 수 있다.

1. 프로세스 제어 (Process Control)
   끝내기(exit), 중지 (abort)
   적재(load), 실행(execute)
   프로세스 생성(create process) - fork
   프로세스 속성 획득과 속성 설정
   시간 대기 (wait time)
   사건 대기 (wait event)
   사건을 알림 (signal event)
   메모리 할당 및 해제
2. 파일 조작 (File Manipulation)
   파일 생성 / 삭제 (create, delete)
   열기 / 닫기 / 읽기 / 쓰기 (open, close, read, wirte)
   위치 변경 (reposition)
   파일 속성 획득 및 설정 (get file attribute, set file attribute)
3. 장치 관리 (Device Manipulation)
   하드웨어의 제어와 상태 정보를 얻음 (ioctl)
   장치를 요구(request device), 장치를 방출 (relese device)
   읽기 (read), 쓰기(write), 위치 변경
   장치 속성 획득 및 설정
   장치의 논리적 부착 및 분리
4. 정보 유지 (Information Maintenance)
   getpid(), alarm(), sleep()
   시간과 날짜의 설정과 획득 (time)
   시스템 데이터의 설정과 획득 (date)
   프로세스 파일, 장치 속성의 획득 및 설정
5. 통신 (Communication)
   pipe(), shm_open(), mmap()
   통신 연결의 생성, 제거
   메시지의 송신, **수신**
   상태 정보 전달
   원격 장치의 부착 및 분리
6. 보호 (Protection)
   chmod()
   umask()
   chown()

<br>

> <b>커널의 개념을 설명하시오</b>

<b>커널(Kernel)</b>: OS 또한 프로그램 중 하나이기 때문에 이것이 실행되려면 주기억장치 즉, RAM에 적재되어있어야 합니다. 하지만, OS를 모두 RAM에 올리기에는 메모리 공간의 낭비가 있으므로, 항상 필요한 운영체제의 핵심 부분만을 메인 메모리에 적재하여 운영체제를 사용하게끔 합니다.

즉, 커널은 메모리에 상주하는 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간 통신을 담당합니다. 주요 기능은 프로세스 스케줄링, 메모리 관리, 입출력 관리 등이며, 시스템 호출을 처리하는 역할을 합니다. 커널은 운영체제의 핵심 모듈로서 하드웨어를 직접 제어하고, 응용 프로그램에 필요한 서비스를 제공합니다.