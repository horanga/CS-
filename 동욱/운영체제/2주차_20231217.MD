<h1>CS 스터디 _ 운영체제 2주차</h1>
<br>
<h2>1. 커널모드의 구체적인 사례</h2>
<h3>커널이란?</h3>

    - CS에서 커널이란 운영체제의 핵심 부분으로서 
      운영체제의 다른 부분이나 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하는 한다.

    - 커널의 역할은 크게 세가지로 나뉜다.
      보안, 자원관리, 추상화

    - 컴퓨터의 자원이란 : CPU, 메모리, 가상메모리 등
      추상적으로는 스레드, 패킷, 프로토콜, 테스크 등 이 있다.
      쉽게 생각하자면 컴퓨터 내부의 모든 것들이다.

    - 운영체제의 커널은 이러한 자원을 효율적으로 관리하기 위해 
      CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등 업무를 수행한다.

<h3>관지라 권한의 실행</h3>

    - 기본적으로 우리가 사용하는 모든 프로그램들은 유저모드로 실행된다.
      관리자 권한 실행은 시스템 콜을 통해 커널모드를 호출하여
      일시적으로 유저모드를 커널모드로 변경해주는 역할을 한다.
    
    - 관리자 권한 실행은 커널모드의 일종이며 기존의 사용자가 접근할 수 없는 
      레지스트리의 접근을 허용해준다.
      * 운영체제 설정 변경
      * 프로그램 설치 및 제거
      * 시스템 서비스 및 드라이버 관리
      * 시스템 보안 설정 변경
     
    - 주의할 점은 관리자 실행을 커널모드 그 자체라고 이해해선 안된다.
      관리자 권한은 레지스트리의 접근 권한을 가졌다면
      커널모드 그 자체는 레지스트리 접근은 물론이며, 프로세스 및 스레드 관리, 메모리 관리, 
      장치 드라이버 상호 작용, 인터럽트 및 예외 처리, 파일 시스템 관리, 시스템 콜 인터페이스 등
      가지고 있는 권한의 차이가 매우 크다. 관리자 권한 실행은 커널모드의 일종임을 잊으면 안된다.

    - 관리자 권한 실행의 목적 

      1. 사용자의 실수로 인한 치명적인 오류 방지 : 
         사용자들은 전문가가 아니기에 레지스트리의 중요한 설정을 모르고 변경하면
         운영체제가 예상치 못한 동작을 일으키거나 치명적인 문제가 발생하여 컴퓨터의 오작동
         위험이 있기에 사용자가 레지스트리의 일반적인 접근을 막는 것이다.

         우리가 컴퓨터에 있는 windows폴더를 감히 함부로 건드리는가? 
         전문가가 아닌 이상 일반인이라면 windows폴더를 건드리지 않는 이유와 같다.

      2. 해커로부터의 데이터를 보호 : 
         관리자 권한 실행은 다음과 같은 의미를 가졌다고 생각하면 된다.
         "너가 정말로 이 컴퓨터 앞에 앉아 있는 관리자가 맞느냐?
         혹시라도 악의적인 의도를 가진 프로그램이 일부러 관리자 권한을 얻으려는 것이 아니냐
         맞다면 네 스스로 마우스를 움직여서 여기 화면에 보이는 예 버튼을 클릭하라"

         이는 악성 프로그램 등으로부터 내 컴퓨터의 데이터의 안전을 지키기위한 
         보안의 목적으로 수동적인 절차이다.
         
         현실 예시 : 집과 도둑 열쇠 

    - 관리자 권한으로 실행은 기존 유저모드가 접근할 수 없던 
      레지스트리를 접근할 수 있는 목적을 가졌다. 
    


<h3><li>디바이스 드라이버</li></h3>

    - 디바이스 드라이버란 특정 하드웨어나 장치를 제어하기 위한 커널의 일종으로 
      동작하는 프로그램이다. 
    
    - 컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치 드라이버가 
      프로그램 커널에 통합되어 실행된다.

    - 컴퓨터의 버스나 통신 시스템을 이용하여 하드웨어와 커널사이에서 명령이나 데이터를 
      전달해주는 역할이다.

    - 쉽게 이야기하자면 우리가 사용하는 모든 입출력장치(마우스, 모니터, 블루투스 키보드, 
      복합기 등)와 컴퓨터(OS)가 서로 알아 들을 수 있도록 통역해주는 역할이라고 생각하면 된다.

    - 프로세스가 실행되는 동안 프로세스는 수없이 유저모드와 커널모드를 왔다갔다하며 실행된다.
      * (유저모드 -> 커널모드 요청)
        프로세스가 유저모드로 실행되다가 특별한 요청이 필요할 때 system call을 이용하여 
        커널에 요청을 한다.

      * (커널모드 -> 유저모드로 반환) 
        system call의 요청을 받는 커널이 그 요청에 대한 일을 하고 결과값을 
        system call이 리턴해준다.
    
    - 흐름 : 
      우리가 사용하는 카카오톡을 예시로 들어보자
      우리는 카카오톡을 실행하기 위해 마우스를 쥐고 커서를 카카오톡 아이콘으로 향하며 
      두번 클릭하고 카카오톡이 정상적으로 실행되는 화면을 모니터를 통해 볼 수 있고
      아이디와 비밀번호를 입력하여 로그인에 정상적으로 성공할 것이다.
      여기서 우리는 마우스와 키보드, 모니터 등으로 커널모드를 왔다갔다 한 것이다.
      
      * 유저모드에 실행되고 있는 유저 어플리케이션에서 시스템 콜이나, 라이브러리 함수를 통해 입출력 요청.
        -> 커널모드로 전환. 커널의 주요 기능 중 하나인 입출력 관리자가 키보드나 드라이버에 요청
        -> 장치드라이버에서 키보드나 모니터에서 받은 return값을 커널에 return
        -> 커널은 해당값을 유저 어플리케이션으로 return
        -> 유저모드로 전환.
<h2>2. 멀티 스레드의 이점과 한계</h2>

    - 멀티 스레드란 : 
      

    - 멀티 스레드의 이점 : 
      * 응답성 : 
        프로그램의 일부분(스레드)가 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어
        사용자에 대한 응답성이 증가한다.
        
        단일 스레드가 순차 실행이고, 멀티 스레드는 병렬 실행이기에 가능하다.
        
        예시 1 : 웹브라우저를 이용할 때 특정한 설치파일을 다운로드 받으면서 
        웹서핑, 쇼핑, 블로그 이용 등 다양한 서비스를 동시에 이용할 수 있는 원리이다.

        예시 2 : 우리가 웹브라우저로 카카오톡 설치, 구글 크롬 설치, 인텔리제이 설치 파일들을
        같이 다운로드 받을 때, 동시에 다운로드가 진행 될 것이다. 이것이 멀티 스레드이다. 

      * 경제성 : 
        프로세스내의 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원의 소비가
        줄어든다. 스레드 간의 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있고
        프로세스의 컨텍스트 스위칭과 달리 스레드의 컨텍스트 스위칭은 
        캐시 메모리를 비울 필요가 없기 때문에 훨씬 빠르다.
        다만 스레드가 다른 CPU 코어에서 실행될 때는 해당 코어의 캐시 메모리에 
        스레드 컨텍스트 정보가 로드되어야 하므로 초기화 될 수 있다.

      * 코드 간결성 : 

    - 멀티 스레드의 한계 : 
      * 임계영역의 동기화 문제 : 
        스레드 컨텍스트가 스위칭이 발생해 다른 스레드가 heap 영역의 공유 데이터에 접근할때, 
        이전 스레드가 이미 공유 자원을 사용하고 있는 경우 동기화 문제가 발생할 수 있다. 
        예를 들어 두개의 스레드가 동시에 하나의 변수를 수정하려고 할 때,
        스레드 컨텍스트 스위칭이 발생하면 변수의 값을 잘못된 값으로 업데이트 할 수 있는 것이다.
        이 것을 스레드 간의 경쟁 조건(race condition)이라고 한다. 
        
        프로세스는 기본적으로 독립된 공간이지만, IPC같은 공유 자원을 사용하는 경우에 
        똑같이 경쟁 조건이 발생 할 수 있다. 
        예를 들어, 여러 개의 프로세스가 동시에 파일 시스템에 접근하여 파일을 수정하려고 할 때, 
        컨텍스트 스위칭이 발생할 때, 다른 프로세스가 그 파일에 접근할 수 있기 때문에 
        파일 내용이 손상 될 수 있다.
        따라서 이들을 해결하기 위해선 각 상황에 적절한 공유 자원에 대한 동기화 메커니즘이 필요해진다.


      * 병목 현상 : 
        멀티 스레딩에서 여러 스레드가 공유 자원에 동시에 접근할 때, 성능이 저하되는 현상을 말함.
        병목 현상은 공유 자원에 대한 경쟁이나 동기화 문제로 인해 발생한다. 
        
      * 컨텍스트 스위칭 오버헤드 : 
        멀티 스레드의 컨텍스트 스위칭이 프로세스의 컨텍스트 스위칭보다 오버헤드가
        훨씬 적다는 장점이 있었을 것이다. 
        하지만, 상대적으로 프로세스에 비해 적다는 것이지 멀티 스레드도 오버헤드 자체 비용을 
        결코 무시할 수 없다.
        즉, 싱글 스레드는 스레드가 한개 이니 컨텍스트 스위칭 오버헤드가 발생하지 않지만, 
        멀티 스레드 모델은 스레드가 여러개이니 컨텍스트 스위칭 오버헤드가 발생하게되고, 
        스레드가 많으면 많을수록 스위칭 횟수가 많아지고 덩달아 오버헤드도 많아져 성능저하가
        될 수 있다. 
        특히 싱글코어 같은 옛날 CPU와 같이 코어 수가 적은데 스레드 수를 계속 늘리면, 
        각 코어에서 경합하는 스레드 수가 점점 많아질 것이고, 어느 순간에는 오버헤드 떄문에 
        성능 한계에 부딪힐 것이다. 

        멀티 코어란? : 
        멀티 스레딩의 응답성 향상, 병렬처리 향상, 멀티 스레딩 최적화 등 
        멀티 스레딩의 종합적인 최적화와 성능향상의 목적을 가지고 있다.
        우리 컴퓨터의 부품중 멀티코어에 8코어 16스레드같은 성능 표시가 있을 것이다.
        여기서 8코어는 우리가 지금 것 배웠던 동시성에 적용된다.
        코어를 통해 동시에 실행되는 것처럼 매우 빠르게 실행되는 것이 멀티 코어가 있기 때문이다.
        즉 1코어는 이러한 동시성 특징을 가진 컨텍스트 스위칭이 불가능하다.
        4코어보다 8코어가 더 동시성과 응답성 등 빠르게 동작하는 차이라고 생각하자.
        즉 멀티 코어가 말하는 코어와 스레드는 멀티 스레딩을 더욱 향상시켜주는 부품이라고 할 수 있다. 

      * 자연 스레드의 리소스 낭비 : 
        많은 양의 작업을 여러개의 스레드로 빠르게 처리한다는 멀티 스레드의 취지는 좋지만,
        회사의 서비스 이용률이 24시간 항상 바쁜 상태는 아닐 것이다. 즉, 멀티 스레드 어플리케이션
        에서 이용률이 한산하여 스레드를 한 두개 밖에 이용하지 않을 때, 나머지 잔여 스레드들이
        CPU, 메모리, 네트워크 등의 자원이 불필요하게 점유해서 성능 저하나 오류의 원인이 될 수 있다.
        놀고 있는 스레드가 많을 수록 불필요하게 메모리를 차지하고 있는 셈이니 당연히 
        시스템 자원의 낭비가 발생한다.
        
        그런데 놀고 있음에도 CPU는 다른 스레드에게 CPU 시간을 양도하도록 설계되어 있기에 
        노는 스레드와 다른 스레드 간에 컨텍스트 스위칭을 하여 CPU의 효율성을 떨어뜨린다. 
        즉, 스레드가 작업을 수행하지 않더라도 존재 자체만으로 여전히 리소스를 소비하고
        오버헤드를 생성하기 때문에 잔여 스레드의 문제는 결코 가볍지 않다. 

        이러한 문제를 해결하기 위해 노는 스레드 갯수를 최소화하고, 스레드 풀(Thread Pool)과 같은 
        메커니즘을 사용하여 스레드의 갯수를 관리하여 리소스 낭비를 최소화 하는 것이 중요하다.

      * 어플리케이션의 성격에 따른 제약 : 
        "스레드를 많이 쓰면 쓸수록 동시에 더 많은 작업들을 실행할 수 있다."라는 말에
        우리도 모르게 암묵적으로 해당 어플리케이션을 더 작은 작업으로 잘게 쪼개서 동시에
        실행이 가능한 어플리케이션이라는 전제를 깔고 생각한다. 
        
        즉, 어플리케이션의 목적과 주제에 따라 아키텍쳐가 달라질 수 있다는 얘기이다.
        예를들어 만약 개발하는 어플리케이션의 동작이 순차적으로 실행되어야만 하는 특징을 가지거나 
        잘게 쪼개서 실행하기에 매우 어려운 성격의 어플리케이션이라면 오히려 멀티 스레드 구성은 
        별 이점이 없다는 것이다. 
        이에 대한 대표적인 예시가 CPU 바운드 어플리케이션과 I/O 바운드 어플리케이션이다. 


      * 프로그래밍 난이도 : 
        싱글 스레드는 단 하나의 스레드가 모든 작업을 처리하기 떄문에, 프로그램 구조가 단순하고 
        개발이 더 쉬우며, CPU, 메모리를 더 적게 사용한다. 

        반면 멀티 스레드는 스레드 간의 동기화 처리, 잘못된 스레드 관리로 인해 
        메모리 누수, 데드락 등의 문제에 대해 관리가 필요하기 때문에 개발이 굉장히 복잡해진다.
        
        멀티 스레드는 분명히 싱글 스레드보다 성능이 뛰어나지만 무턱되고 멀티 스레드로
        개발을 진행하다가 온갖 동시성 문제에 직면하여, 어플리케이션의 안정성과 유지보수성을 
        저해하는 것은 두마리의 토끼를 잡으려다가 한마리도 못잡는 격이 될 수 있으니
        높은 수준의 역량과 경험이 요구되며, 모델 선택에 있어, 신중하게 고려하고, 
        프로그램의 특성과 목적에 따라 멀티 스레딩 전략을 선택하고, 
        성능 최적화와 동시성 관련 이슈들에 대한 철저한 이해와 학습이 필요하다. 