### 1.IDE(통합개발환경)에서 컴파일하는 것과 커널 모드의 관계를 설명하시오

* * *

    우리가 사용하는 프로그래밍 언어로 명령어를 작성하면 이에 알맞는 메모리 자원을 할당해야 한다. c언어 같은 경우는 메모리를 할당받은 뒤 
    해당 구문이 더는 필요하지 않다면 free()를 처리해서 자원을 반납해준다고 한다. java와 같은 언어는 GC(Garbage Collection)을 지원하면서
    이용자가 직접 사용하지 않는 메모리를 반납하지 않도록 하고 있다.

    c언어는 메모리를 할당할 때 malloc같은 명령어를 수행하는데, 원래 특정 프로세스에 메모리를 할당하는 것은 운영체제의 역할이다. malloc를 수행하면
    내부적으로 시스템이 콜이 발생해서 운영체제에 메모리 할당을 요청하는 것이다.

    cf)프로세스는 일반적인 사용자모드와 PC의 주요 하드웨어 자원을 사용할 수 있는 커널모드를 왔다갔다 한다. 시스템콜이 발생하면,
    운영체제가 커널모드를 실행해서 프로세스에 하드웨어 자원을 할당한다. 참고로, 컴파일은 프로그래밍 언어를 커널이 이해할 수 있게 변환시켜주는 작업이라고 이해했다.

    c언어는 포인터를 통해서 메모리에 직접 접근할 수 있는데, 이 구조 덕분에 시스템콜을 다이렉트로 발생시킬 수 있다고 한다.(malloc는 시스템콜 자체가 아니라 
    시스템콜을 사용하는 API라고 함)
    반면, java는 시스템 콜을 간접적으로 사용한다.

    I/O가 발생하는 예시를 들어보자. C프로세스는 시스템 콜을 요청하고, 커널모드로 가서 디스크 컨트롤러를 통해 데이터를 복사한다. 
    자바는 JVM -> JNI(Java Native Interface) -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사 흐름으로 작동한다.
    내 생각엔 System.out.println같은 코드가 시스템 호출을 사용할 때 쓰는 API인것 같다! 이를 통해 JVM은 콘솔에 텍스트를 출력하기 위해 운영체제의 파일 또는 스트림 쓰기 기능에 접근해야 한다고 한다.
    개발자는 운영체제의 복잡한 파일 시스템이나 콘솔 관리 기능을 직접 다룰 필요 없이 간편하게 출력할 수 있다.

코드를 작성할 때 막연하게 메모리를 적게 사용하는 방식이 좋다는 정도로만 이해했었다. 알고리즘 문제 사이트들을 보면 컴파일 때 메모리를 체크하던데 실제로 메모리자원을 효율적으로 사용하는지
체크하기 위해서였다는 걸 이제 정확하게 이해했다.




__참고자료 https://brewagebear.github.io/java-syscall-and-io/__

### 2.CPU 스케쥴링은 서버 성능에 어떻게 영향을 미치는지 설명하시오

* * *

    CPU스케쥴링은 프로세스에 CPU 자원을 할당하는 정책을 말한다. 프로세스들에게 현명하게 CPU를 배분하지 못하면 반드시 실행돼야 할 프로세스가 실행되지 못하거나,
    당장 급하지 않은 프로세스들만 주로 실행되는 것처럼 무질서한 상태가 발생할 수 있다. 운영체제는 프로세스마다 PCB(Process Control Block)에 우선순위를 명시해서 먼저 처리할 프로세스를 정한다.

    주로 입출에 집중된 프로세스들이 우선순위가 높은 프로세스에 속한다. 이 프로세스는 CPU 집중 프로세스와 달리 CPU를 많이 사용하지 않는다. CPU집중 프로세스와 입출력 집중 프로세스가
    동시에 CPU자원을 요구했다고 가정해보자. 이때, 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력장치를 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당시키는 것이다.
    쉽게 생각하면, 입출력 집중 프로세스는 짧게 CPU 조금 쓰고 그 다음부터는 계속 입출력장치를 쓴다. 입출력장치를 쓰는 동안에는 이 CPU를 놀리지 않고 다른 프로세스에 할당할 수 있다.

    +입출력 집중 프로세스를 먼저 쓰면 좋은 또 다른 이점으로는 이용자 경험을 향상시킬 수 있다는 것이다. 이용자 입장에서는 디스플레이에 결과물이 더 빨리 뜨니까.

    PCB에 우선순위가 적혀 있지만, CPU를 사용할 프로세스를 찾기 위해서 모든 프로세스의 PCB를 확인하는 것은 비효율적이다. 그래서, 운영체제는 프로세스에게 '줄을 서서 기다려라'라고 요구한다.   
    그리고, 운영체제는 이 줄을 '스케쥴링 큐'로 구현해서 관리한다.(여기서 큐는 일반적인 자료구조처럼 선입선출의 방식일 필요는 없다고 한다) 
    대표적인 큐로는 준비큐(ready queue, CPU를 이용하고 싶은 프로세스가 서는 줄)와 대기큐(waiting queue, 입출력장치를 쓰려는 프로세스들이 서는 줄)가 있다.

    *우선순위가 높은 프로세스가 큐의 맨 앞에 있지 않더라도 먼저 처리될 수 있다. 우선순위는 마치 특별혜택을 받는 VIP와 같은 것이다.

    스케쥴링 방식에는 1)선점형 스케쥴링 2)비선점형 스케쥴링이 있다. 선점형 스케쥴링은 지금 CPU를 사용하고 있는 프로세스로부터 CPU 자원을 빼았아 다른 프로세스에 할당하는 방식이다.
    프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 다 써서 타임 인터럽트가 발생하고 운영체제가 CPU를 회수하는 것이 대표 사례다.
    비선점형 스케쥴링은 하나의 프로세스가 CPU자원을 사용하고 있으면 종료되거나, 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들지 못하는 방식을 말한다. 
    (현재 대부분의 운영체제는 선점형 스케쥴링을 사용하는데, 단점은 문맥 교환과정에서 오버헤드가 발생할 수 있다는 것이다)

    스케쥴링이 서버 성능에 직접적으로 영향을 미치는 부분은 특정 알고리즘의 장점들을 살펴봐야 한다. 
    스케쥴링의 기준이라는 것이 있는데, 대표적으로 처리량과 응답시간 자원활용 대기시간 우선순위 공정성이 있다. 

    처리량을 기준으로 하면, 처리 시간이 짧은 것들을 먼저 처리해서 시간당 작업량을 늘릴 수 있다. 응답시간을 기준으로 하면, 모든 프로세스에 공평한 시간동안 CPU를 할당해서 다음 프로세스가   
    오래 기다리지 않도록 할 수 있다.

    좀더 구체적인 예를 들면, 배치 처리 시스템에서는 가능한 많은 작업을 완료하는 게 중요하므로 처리량을 늘리는 것이 더 중요하다. 그래서 처리 시간이 짧은 작업부터 먼저 처리해서 전체 처리량을 늘릴 수 있다.
    대화형 시스템에서는 사용자 질의에 빠르게 응답하는 것이 중요하므로 응답시간을 최소화하는 알고리즘이 필요하다. 
    특정 스케쥴링 알고리즘이 모든 목표에서 최적이 될 수는 없으니 목표에 따라 적절한 알고리즘을 쓰는 게 중요할 거 같다.


__참고자료 -혼자 공부하는 컴퓨터구조+운영체제(강민철 지음)__

### 3.CPU 스케쥴링을 할 때 활용하는 알고리즘을 설명하시오.
* * *
    1)선입 선처리 스케쥴링 (FCFS, First Com First Served Scheduling)
    -준비 큐에 삽입된 순서대로 프로세스를 처리하는 비선점형 스케쥴링이다. 가장 공정해 보이는 선입선처리 방식이지만, 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 단점이 있다.
    CPU를 오래 쓰는 프로세스가 먼저 처리되면 그 시간 동안 다른 프로세스들은 기다려야만 하는 것이다. 

    ex)파일 다운로드 요청이 먼저 들어오고, 이후 웹 페이지 요청이 들어왔다면 이때 순서대로 파일 다운로드를 먼저 처리하고 웹페이지 요청을 처리하는 방식
    
    *호위 효과(convoy effect): 17ms동안 CPU를 사용하는 프로세스 A, 5ms를 사용하는 프로세스B, 2ms를 사용하는 프로세스 C가 순서대로 들어온다면
    C는 처리될 때까지 (처리되는데는 고작 2ms만 걸리지만)22ms를 기다려야 하는데 이를 호위효과라고 한다. 
    
    2)최단 작업 우선 스케쥴링(SFJ, Shortest Job First Scheudling)
    -호위 효과를 방지하려면 어떻게 해야할까? 단순하게 생각해보면, 사용 시간이 긴 프로세스는 나중에 처리하고 CPU 사용시간이 짧은 간단한 프로세스를 먼저 처리하면 된다.
    
    ex)프린터 처리 프로그램에서 프린트 작업이 여러개 대기 중일 때, 가장 페이지 수가 적은 문서부터 먼저 프린터 하는 방식

    3)라운드 로빈 스케쥴링(Round Robin Scheudling)
    -선입선처리 스케쥴링에 타임 슬라이스라는 개념이 더해졌다. 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 뜻한다. 그니까, 먼저 들어온 프로세스대로 처리하면서,
    정해진 시간만큼만 CPU를 사용하게 하는 것이다. 라운드 로빈 스케쥴링의 경우에는 타임 슬라이스 시간을 잘 정하는 게 중요하다. 타임 슬라이스가 너무 길어지면 여전히 호위 효과가 발생하고    
    타임 슬라이스가 너무 작으면 문맥 교환에 발생하는 비용이 커서 CPU 프로세슷 처리하는 일보다 프로세스를 전환하는 데 더 많은 자원을 쓰기 때문이다.
 
    4)최소 잔여 시간 우선 스케쥴링(Shortest Remaining Time Scheudling) 
    -최단 작업 우선 스케쥴링 알고리즘과 라운드 로빈 스케쥴링을 합친 방식이다. 작업 시간이 짧은 프로세스부터 처리하면서, 정해진 시간이 지나면 그 다음 프로세스를 처리하는 것.

    5)우선 순위 스케쥴링(priority Scheduling)
    -프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 처리한다. 최단 작업 우선 스케쥴링, 최소 잔여시간 우선 스케쥴링도 큰 의미에선 우선 순위 스케쥴링이다.
    우선 순위 스케쥴링에서는, 우선 순위가 높은 프로세스를 먼저 처리하다보니 우선 순위가 낮은 프로세스들 때문에 실행이 계속해서 연기될 수 있다. 이를 기아 현상이라고 한다.
    이를 방지하는 대표적인 기법이 에이징이다. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다. (우선순위가 낮더라도 언젠가는 높은 우선순위가 된다.)

    ex)메모리 관리나 보안 관련 프로세스는 일반 응용 프로그램보다 더 높은 우선순위를 갖고 처리된다.

    6)다단계 큐 스케쥴링(Multilevel Queue Scheduling)
    -우선순위별로 준비 큐를 여러 개 사용하는 방식이다. 예를 들면, 준비 큐를 3개 놓고 제일 위를 우선순위0 큐 그 다음을 우선순위 1큐 우선순위2큐로 놓는 것이다.
    우선순위 0큐가 비어있으면 그 다음 우선순위 큐를 처리한다. 비교적 우선순위가 높은 프로세스들을 우선순위가 높은 큐에, 그렇지 않은 프로세스들을 우선순위가 낮은 큐에 놓을 수 있다.
    또한, 우선순위큐마다 타임 슬라이스를 다르게 지정할 수 있고, 큐마다 다른 스케쥴링 알고리즘을 적용할 수 있다는 점도 특징이다.

    ex)네트워크 라우터나 스위치에서 다양한 우선순위의 트래픽(예: 음성, 비디오, 데이터)을 다른 큐로 관리하여, 중요한 트래픽에 더 빠른 서비스를 제공할 수 있다.
    
    7)다단계 피드백 큐 스케쥴링
    -다단계 큐 스케쥴링에서는 프로세스들이 큐 사이를 이동하지 못한다. 이런 방식이라면 우선 순위가 낮은 프로세스들은 계속 처리가 연기될 수 있다.    
    이를 방지하기 위해서, 프로세스들이 큐 사이를 이동할 수 있도록 한다. a라는 프로세스가 우선순위0큐에서 먼저 처리된다고 해보자. 그런데, 타임슬라이스동안 작업을 모두 끝내지 못했다.  
    이런 경우 프로세스를 다음 우선순위 큐에 삽입하는 것이다.CPU를 비교적 오래 사용하는 프로세스들은 우선순위가 점점 낮아지도록 처리할 수 있다. 
    반대로, 어떤 프로세스가 낮은 우선순위 큐에서 오래 기다린다면 더 높은 우선순위 큐로 이동시킬 수 있다. 다단계 피드백 큐 스케쥴링은 가장 일반적으로 쓰이는 CPU 스케쥴링 알고리즘이라고 한다.

    ex)웹 서버에서는 각 클라이언트 요청의 처리 상태를 추적한다고  한다. 어떤 요청이 너무 오랫동안 대기하고 있다면, 서버는 이를 감지하고 해당 요청의 우선순위를 높여 더 빠르게 처리할 수 있다.

### 4.시스템 호출의 구체적인 사례를 설명하시오.
* * *
    시스템 호출이란 사용자 모드로 실행되는 프로그램이 하드웨어 자원에 접근하는 운영체제 서비스를 제공받기 위해서 보내는 요청이다. 시스템 호출은 일종의 인터럽트라고 할 수 있다(소프트웨어적 인터럽트)
    한 응용 프로그램이 하드 디스크에 데이터를 저장한다고 해보자. 이때 하드 디스크에 접근하기 위해서 커널 모드로 전환해야 한다. 응용 프로그램은 하드 디스크에 데이터를 저장하는 시스템 호출을 발생시켜서 
    커널 모드로 전환하고, 운영체제 내에 있는 '하드 디스크에 데이터를 저장하는 코드'를 실행함으로써 하드 디스크에 접근한다. 

    시스템 호출의 종류로는 
    1)프로세스 관리 
    -fork() -새 자식 프로세스 생성
    -exeve() - 프로세스 실행(메모리 공간에 새로운 프로그램의 내용으로 덮어 씌움)
    -exit() - 프로세스 종료
    -waitpid() - 자식 프로세스가 종료할 때까지 대기

    2)파일 관리
    -open() -파일 열기
    -close() -파일 닫기
    -read() -파일 읽기
    -write() 파일 쓰기
    -stat() -파일 정보 획득

    3)디렉터리 관리
    -chdir() -작업 디렉터리 변경
    -mkdir() - 디렉터리 생성
    -rmdir() -비어있는 디렉터리 삭제

    4)파일 시스템 관리
    -mount() - 파일 시스템 마운트
    -umount() - 파일 시스템 마운트 해제

    *우리가 cmd에서 mkdir을 입력하면 새 폴더를 생성할 수 있는데, 이건 어떤 연관이 있는걸까?
    -생각해보면, 우리는 마우스를 통해서 문서나 파일을 생성하고 삭제한다. 데이터를 저장하는 작업도 한다. 이런 일련의 작업들은 커널 모드에서 실행돼야 하는데, 이건 간접적으로 시스템을 호출하는 방식이라고 이해했다.
    그렇다면, cmd에 명령어를 입력하는 것도 GUI를 통한 작업들과 마찬가지로 간접적으로 시스템을 호출하는 방식이 아닐까 한다.