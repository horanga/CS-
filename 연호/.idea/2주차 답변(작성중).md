### 1.IDE(통합개발환경)에서 컴파일하는 것과 커널 모드의 관계를 설명하시오

* * *

    우리가 사용하는 프로그래밍 언어로 명령어를 작성하면 이에 알맞는 메모리 자원을 할당해야 한다. c언어 같은 경우는 메모리를 할당받은 뒤 
    해당 구문이 더는 필요하지 않다면 free()를 처리해서 자원을 반납해준다고 한다. java와 같은 언어는 GC(Garbage Collection)을 지원하면서
    이용자가 직접 사용하지 않는 메모리를 반납하지 않도록 하고 있다.

    c언어는 메모리를 할당할 때 malloc같은 명령어를 수행하는데, 원래 특정 프로세스에 메모리를 할당하는 것은 운영체제의 역할이다. malloc를 수행하면
    내부적으로 시스템이 콜이 발생해서 운영체제에 메모리 할당을 요청하는 것이다.

    cf)프로세스는 일반적인 사용자모드와 PC의 주요 하드웨어 자원을 사용할 수 있는 커널모드를 왔다갔다 한다. 시스템콜이 발생하면,
    운영체제가 커널모드를 실행해서 프로세스에 하드웨어 자원을 할당한다. 참고로, 컴파일은 프로그래밍 언어를 커널이 이해할 수 있게 변환시켜주는 작업이라고 이해했다.

    c언어는 포인터를 통해서 메모리에 직접 접근할 수 있는데, 이 구조 덕분에 시스템콜을 다이렉트로 발생시킬 수 있다고 한다.(malloc는 시스템콜 자체가 아니라 
    시스템콜을 사용하는 API라고 함)
    반면, java는 시스템 콜을 간접적으로 사용한다.

    I/O가 발생하는 예시를 들어보자. C프로세스는 시스템 콜을 요청하고, 커널모드로 가서 디스크 컨트롤러를 통해 데이터를 복사한다. 
    자바는 JVM -> JNI(Java Native Interface) -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사 흐름으로 작동한다.
    내 생각엔 System.out.println같은 코드가 시스템 호출을 사용할 때 쓰는 API인것 같다! 이를 통해 JVM은 콘솔에 텍스트를 출력하기 위해 운영체제의 파일 또는 스트림 쓰기 기능에 접근해야 한다고 한다.
    개발자는 운영체제의 복잡한 파일 시스템이나 콘솔 관리 기능을 직접 다룰 필요 없이 간편하게 출력할 수 있다.



   
참고자료 https://brewagebear.github.io/java-syscall-and-io/